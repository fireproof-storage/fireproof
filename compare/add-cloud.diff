+++ b/cloud-backend/connection.test.ts
+import { ensureSuperThis, ps } from "@fireproof/core";
+import { Result, URI } from "@adviser/cement";
+// import { HonoServer } from "./hono-server.js";
+// import { Hono } from "hono";
+import { calculatePreSignedUrl } from "./pre-signed-url.js";
+import { httpStyle, mockJWK, MockJWK, NodeHonoServerFactory, wsStyle } from "./test-helper.js";
+
+const {
+  buildReqGestalt,
+  buildReqOpen,
+  MsgIsError,
+  MsgIsResGestalt,
+  MsgIsResOpen,
+  defaultGestalt,
+  MsgIsResGetData,
+  MsgIsResPutData,
+  MsgIsResDelData,
+  buildReqPutData,
+  buildReqDelData,
+  buildReqGetData,
+  buildReqGetWAL,
+  buildReqPutWAL,
+  buildReqDelWAL,
+  MsgIsResGetWAL,
+  MsgIsResPutWAL,
+  MsgIsResDelWAL,
+  applyStart,
+  defaultMsgParams,
+  Msger,
+  buildReqDelMeta,
+  buildBindGetMeta,
+  buildReqPutMeta,
+  MsgIsResDelMeta,
+  MsgIsEventGetMeta,
+  MsgIsResPutMeta,
+  MsgConnected,
+} = ps.cloud;
+type MsgBase = ps.cloud.MsgBase;
+type MsgWithError<T extends MsgBase> = ps.cloud.MsgWithError<T>;
+type ReqSignedUrlParam = ps.cloud.ReqSignedUrlParam;
+type GwCtx = ps.cloud.GwCtx;
+type ResOptionalSignedUrl = ps.cloud.ResOptionalSignedUrl;
+type ReqOpen = ps.cloud.ReqOpen;
+type MethodSignedUrlParam = ps.cloud.MethodSignedUrlParam;
+type ResDelMeta = ps.cloud.ResDelMeta;
+type ReqDelMeta = ps.cloud.ReqDelMeta;
+type BindGetMeta = ps.cloud.BindGetMeta;
+type EventGetMeta = ps.cloud.EventGetMeta;
+type MsgConnectedAuth = ps.cloud.MsgConnectedAuth;
+
+async function refURL(sp: ResOptionalSignedUrl) {
+  const { env } = {
+    env: process.env as {
+      STORAGE_URL: string;
+      ACCESS_KEY_ID: string;
+      SECRET_ACCESS_KEY: string;
+      REGION: string;
+    },
+  };
+  return (
+    await calculatePreSignedUrl(sp, {
+      storageUrl: URI.from(env.STORAGE_URL),
+      aws: {
+        accessKeyId: env.ACCESS_KEY_ID,
+        secretAccessKey: env.SECRET_ACCESS_KEY,
+        region: env.REGION,
+      },
+      test: {
+        amzDate: URI.from(sp.signedUrl).getParam("X-Amz-Date"),
+      },
+    })
+  )
+    .Ok()
+    .asObj();
+}
+
+describe("Connection", () => {
+  const sthis = ensureSuperThis();
+  const msgP = defaultMsgParams(sthis, { hasPersistent: true });
+  let auth: MockJWK;
+  // let privEnvJWK: string
+
+  beforeAll(async () => {
+    // sthis.env.sets((await resolveToml()).env as unknown as Record<string, string>);
+    auth = await mockJWK();
+    // privEnvJWK = await jwk2env(keyPair.privateKey, sthis);
+  });
+
+  describe.each([
+    // force multiple lines
+    NodeHonoServerFactory(sthis),
+  ])("$name - Connection", (honoServer) => {
+    const port = honoServer.port;
+    // const port = +(process.env.FP_WRANGLER_PORT || 0) || 1024 + Math.floor(Math.random() * (65536 - 1024));
+    const my = defaultGestalt(msgP, { id: "FP-Universal-Client" });
+
+    const styles: { name: string; action: () => ReturnType<typeof wsStyle> | ReturnType<typeof httpStyle> }[] =
+      honoServer.name === "NodeHonoServer"
+        ? [
+            // force multiple lines
+            { name: "http", action: () => httpStyle(sthis, auth.applyAuthToURI, port, msgP, my) },
+            { name: "ws", action: () => wsStyle(sthis, auth.applyAuthToURI, port, msgP, my) },
+          ]
+        : [];
+
+    describe.each(styles)(`${honoServer.name} - $name`, (styleFn) => {
+      let style: ReturnType<typeof wsStyle> | ReturnType<typeof httpStyle>;
+      // let server: HonoServer;
+      let qOpen: ReqOpen;
+      beforeAll(async () => {
+        style = styleFn.action();
+        // const app = new Hono();
+        qOpen = buildReqOpen(sthis, auth.authType, { reqId: "req-open-test" });
+        // server = await honoServer
+        //   .factory(sthis, msgP, style.remoteGestalt, port, auth.keys.strings.publicKey)
+        //   .then((srv) => srv.once(app, port));
+      });
+      afterAll(async () => {
+        // console.log("closing server");
+        // await server.close();
+      });
+
+      it(`conn refused`, async () => {
+        const rC = await applyStart(style.connRefused.open());
+        expect(rC.isErr()).toBeTruthy();
+        expect(rC.Err().message).toMatch(/ECONNREFUSED/);
+      });
+
+      it(`timeout`, async () => {
+        const rC = await applyStart(style.timeout.open());
+        expect(rC.isErr()).toBeTruthy();
+        expect(rC.Err().message).toMatch(/Timeout/i);
+      });
+
+      describe(`connection`, () => {
+        let c: MsgConnectedAuth;
+        beforeEach(async () => {
+          const rC = await style.ok.open().then((r) => MsgConnected.connect(auth.authType, r, { reqId: "req-open-testx" }));
+          expect(rC.isOk()).toBeTruthy();
+          c = rC.Ok().attachAuth(() => Promise.resolve(Result.Ok(auth.authType)));
+          expect(c.conn).toEqual({
+            reqId: "req-open-testx",
+            resId: c.conn.resId,
+          });
+        });
+        afterEach(async () => {
+          await c.close((await c.msgConnAuth()).Ok());
+        });
+
+        it("kaputt url http", async () => {
+          const r = await c.raw.request(
+            {
+              tid: "test",
+              auth: auth.authType,
+              type: "kaputt",
+              version: "FP-MSG-1.0",
+            },
+            { waitFor: () => true },
+          );
+          if (!MsgIsError(r)) {
+            assert.fail("expected MsgError");
+            return;
+          }
+          expect(r).toEqual({
+            message: "unexpected message",
+            auth: auth.authType,
+            tid: "test",
+            type: "error",
+            version: "FP-MSG-1.0",
+            src: {
+              tid: "test",
+              auth: auth.authType,
+              type: "kaputt",
+              version: "FP-MSG-1.0",
+            },
+          });
+        });
+        it("gestalt url http", async () => {
+          const msgP = defaultMsgParams(sthis, {});
+          const req = buildReqGestalt(sthis, auth.authType, defaultGestalt(msgP, { id: "test" }));
+          const r = await c.raw.request(req, { waitFor: MsgIsResGestalt });
+          if (!MsgIsResGestalt(r)) {
+            assert.fail("expected MsgError", JSON.stringify(r));
+          }
+          expect(r.gestalt).toEqual({
+            ...c.exchangedGestalt?.remote,
+            id: r.gestalt.id,
+          });
+        });
+
+        it("openConnection", async () => {
+          const req = buildReqOpen(sthis, auth.authType, { ...c.conn });
+          const r = await c.raw.request(req, { waitFor: MsgIsResOpen });
+          if (!MsgIsResOpen(r)) {
+            assert.fail(JSON.stringify(r));
+          }
+          expect(r).toEqual({
+            conn: { ...c.conn, resId: r.conn?.resId },
+            auth: auth.authType,
+            tid: req.tid,
+            type: "resOpen",
+            version: "FP-MSG-1.0",
+          });
+        });
+      });
+
+      it("open", async () => {
+        const rC = await Msger.connect(sthis, auth.authType, style.ok.url(), msgP, {
+          reqId: "req-open-testy",
+        });
+        expect(rC.isOk()).toBeTruthy();
+        const c = rC.Ok().attachAuth(() => Promise.resolve(Result.Ok(auth.authType)));
+        expect(c.conn).toEqual({
+          reqId: "req-open-testy",
+          resId: c.conn.resId,
+        });
+        expect(c.raw).toBeInstanceOf(style.cInstance);
+        expect(c.exchangedGestalt).toEqual({
+          my,
+          remote: { ...style.remoteGestalt, id: c.exchangedGestalt.remote.id },
+        });
+        await c.close((await c.msgConnAuth()).Ok());
+      });
+      describe(`${honoServer.name} - Msgs`, () => {
+        let gwCtx: GwCtx;
+        let conn: MsgConnectedAuth;
+        beforeAll(async () => {
+          const rC = await Msger.connect(sthis, auth.authType, `http://localhost:${port}/`, msgP, qOpen.conn);
+          expect(rC.isOk()).toBeTruthy();
+          conn = rC.Ok().attachAuth(() => Promise.resolve(Result.Ok(auth.authType)));
+          gwCtx = {
+            conn: conn.conn,
+            tenant: {
+              tenant: "Tenant",
+              ledger: "Ledger",
+            },
+          };
+        });
+        afterAll(async () => {
+          await conn.close((await conn.msgConnAuth()).Ok());
+        });
+        it("Open", async () => {
+          const res = await conn.raw.request(buildReqOpen(sthis, auth.authType, conn.conn), {
+            waitFor: MsgIsResOpen,
+          });
+          if (!MsgIsResOpen(res)) {
+            assert.fail("expected MsgResOpen", JSON.stringify(res));
+          }
+          expect(MsgIsResOpen(res)).toBeTruthy();
+          expect(res.conn).toEqual({ ...qOpen.conn, resId: res.conn.resId });
+        });
+
+        function sup(mp: MethodSignedUrlParam) {
+          return {
+            auth: auth.authType,
+            methodParam: mp,
+            params: {
+              path: "test/me",
+              key: "key-test",
+            },
+          } satisfies ReqSignedUrlParam;
+        }
+        describe("Data", async () => {
+          it("Get", async () => {
+            const sp = sup({ method: "GET", store: "file" });
+            const res = await conn.request(buildReqGetData(sthis, sp, gwCtx), { waitFor: MsgIsResGetData });
+            if (MsgIsResGetData(res)) {
+              // expect(res.params).toEqual(sp);
+              expect(URI.from(res.signedUrl).asObj()).toEqual(await refURL(res));
+            } else {
+              assert.fail("expected MsgResGetData", JSON.stringify(res));
+            }
+          });
+          it("Put", async () => {
+            const sp = sup({ method: "PUT", store: "file" });
+            const res = await conn.request(buildReqPutData(sthis, sp, gwCtx), { waitFor: MsgIsResPutData });
+            if (MsgIsResPutData(res)) {
+              // expect(res.params).toEqual(sp);
+              expect(URI.from(res.signedUrl).asObj()).toEqual(await refURL(res));
+            } else {
+              assert.fail("expected MsgResPutData", JSON.stringify(res));
+            }
+          });
+          it("Del", async () => {
+            const sp = sup({ method: "DELETE", store: "file" });
+            const res = await conn.request(buildReqDelData(sthis, sp, gwCtx), { waitFor: MsgIsResDelData });
+            if (MsgIsResDelData(res)) {
+              // expect(res.params).toEqual(sp);
+              expect(URI.from(res.signedUrl).asObj()).toEqual(await refURL(res));
+            } else {
+              assert.fail("expected MsgResDelData", JSON.stringify(res));
+            }
+          });
+        });
+
+        describe("Meta", async () => {
+          it("bind stop", async () => {
+            const sp = sup({ method: "GET", store: "meta" });
+            expect(conn.raw.activeBinds.size).toBe(0);
+            const streams: ReadableStream<MsgWithError<EventGetMeta>>[] = Array(5)
+              .fill(0)
+              .map(() => {
+                return conn.bind<EventGetMeta, BindGetMeta>(buildBindGetMeta(sthis, auth.authType, sp.params, gwCtx), {
+                  waitFor: MsgIsEventGetMeta,
+                });
+              });
+            for await (const stream of streams) {
+              const reader = stream.getReader();
+              while (true) {
+                const { done, value: msg } = await reader.read();
+                if (done) {
+                  break;
+                }
+                if (MsgIsEventGetMeta(msg)) {
+                  // expect(msg.params).toEqual(sp);
+                  expect(URI.from(msg.signedUrl).asObj()).toEqual(await refURL(msg));
+                } else {
+                  assert.fail("expected MsgEventGetMeta", JSON.stringify(msg));
+                }
+                await reader.cancel();
+              }
+            }
+            expect(conn.raw.activeBinds.size).toBe(0);
+            // await Promise.all(streams.map((s) => s.cancel()));
+          });
+
+          it("Get", async () => {
+            const sp = sup({ method: "GET", store: "meta" });
+            const res = await conn.request(buildBindGetMeta(sthis, auth.authType, sp.params, gwCtx), {
+              waitFor: MsgIsEventGetMeta,
+            });
+            if (MsgIsEventGetMeta(res)) {
+              // expect(res.params).toEqual(sp);
+              expect(URI.from(res.signedUrl).asObj()).toEqual(await refURL(res));
+            } else {
+              assert.fail("expected MsgIsEventGetMeta", JSON.stringify(res));
+            }
+          });
+          it("Put", async () => {
+            const sp = sup({ method: "PUT", store: "meta" });
+            const metas = {
+              metas: Array(5)
+                .fill({ cid: "x", parents: [], data: "MomRkYXRho" })
+                .map((data) => {
+                  return { ...data, cid: sthis.timeOrderedNextId().str };
+                }),
+              keys: Array(5)
+                .fill("")
+                .map(() => sthis.timeOrderedNextId().str),
+            };
+            const res = await conn.request(buildReqPutMeta(sthis, auth.authType, sp.params, metas, gwCtx), {
+              waitFor: MsgIsResPutMeta,
+            });
+            if (MsgIsResPutMeta(res)) {
+              // expect(res.params).toEqual(sp);
+              expect(URI.from(res.signedUrl).asObj()).toEqual(await refURL(res));
+            } else {
+              assert.fail("expected MsgIsResPutMeta", JSON.stringify(res));
+            }
+          });
+          it("Del", async () => {
+            const sp = sup({ method: "DELETE", store: "meta" });
+            const res = await conn.request<ResDelMeta, ReqDelMeta>(buildReqDelMeta(sthis, auth.authType, sp.params, gwCtx), {
+              waitFor: MsgIsResDelMeta,
+            });
+            if (MsgIsResDelMeta(res)) {
+              // expect(res.params).toEqual(sp);
+              expect(URI.from(res.signedUrl).asObj()).toEqual(await refURL(res));
+            } else {
+              assert.fail("expected MsgResDelWAL", JSON.stringify(res));
+            }
+          });
+        });
+        describe("WAL", async () => {
+          it("Get", async () => {
+            const sp = sup({ method: "GET", store: "wal" });
+            const res = await conn.request(buildReqGetWAL(sthis, sp, gwCtx), { waitFor: MsgIsResGetWAL });
+            if (MsgIsResGetWAL(res)) {
+              // expect(res.params).toEqual(sp);
+              expect(URI.from(res.signedUrl).asObj()).toEqual(await refURL(res));
+            } else {
+              assert.fail("expected MsgResGetWAL", JSON.stringify(res));
+            }
+          });
+          it("Put", async () => {
+            const sp = sup({ method: "PUT", store: "wal" });
+            const res = await conn.request(buildReqPutWAL(sthis, sp, gwCtx), { waitFor: MsgIsResPutWAL });
+            if (MsgIsResPutWAL(res)) {
+              // expect(res.params).toEqual(sp);
+              expect(URI.from(res.signedUrl).asObj()).toEqual(await refURL(res));
+            } else {
+              assert.fail("expected MsgResPutWAL", JSON.stringify(res));
+            }
+          });
+          it("Del", async () => {
+            const sp = sup({ method: "DELETE", store: "wal" });
+            const res = await conn.request(buildReqDelWAL(sthis, sp, gwCtx), { waitFor: MsgIsResDelWAL });
+            if (MsgIsResDelWAL(res)) {
+              // expect(res.params).toEqual(sp);
+              expect(URI.from(res.signedUrl).asObj()).toEqual(await refURL(res));
+            } else {
+              assert.fail("expected MsgResDelWAL", JSON.stringify(res));
+            }
+          });
+        });
+      });
+    });
+  });
+});
+++ b/cloud-backend/hono-server.ts
+import { exception2Result, HttpHeader, Logger, param, Result, top_uint8, URI } from "@adviser/cement";
+import { SuperThis, ps, rt } from "@fireproof/core";
+import { Context, Hono, Next } from "hono";
+import { WSContext, WSContextInit, WSMessageReceive } from "hono/ws";
+// import { CFExposeCtxItem } from "./cf-hono-server.js";
+import { metaMerger } from "./meta-merger/meta-merger.js";
+import { SQLDatabase } from "./meta-merger/abstract-sql.js";
+import { WSRoom } from "./ws-room.js";
+import { MsgDispatcher, MsgDispatcherCtx, Promisable, WSConnectionPair } from "./msg-dispatch.js";
+import { calculatePreSignedUrl } from "./pre-signed-url.js";
+import { buildMsgDispatcher } from "./msg-dispatcher-impl.js";
+
+type BindGetMeta = ps.cloud.BindGetMeta;
+type ReqPutMeta = ps.cloud.ReqPutMeta;
+type ReqDelMeta = ps.cloud.ReqDelMeta;
+type ResPutMeta = ps.cloud.ResPutMeta;
+type ResDelMeta = ps.cloud.ResDelMeta;
+type EventGetMeta = ps.cloud.EventGetMeta;
+type MsgTypesCtx = ps.cloud.MsgTypesCtx;
+type PreSignedMsg = ps.cloud.PreSignedMsg;
+type MsgWithError<T extends ps.cloud.MsgBase> = ps.cloud.MsgWithError<T>;
+type AuthType = ps.cloud.AuthType;
+type FPCloudAuthType = ps.cloud.FPCloudAuthType;
+type MsgWithConnAuth<T extends ps.cloud.MsgBase> = ps.cloud.MsgWithConnAuth<T>;
+type GwCtx = ps.cloud.GwCtx;
+type MsgBase = ps.cloud.MsgBase;
+
+const { buildEventGetMeta, buildRes, buildErrorMsg, isAuthTypeFPCloudJWK, MsgIsError, buildResPutMeta, buildResDelMeta } = ps.cloud;
+
+// export interface RunTimeParams {
+//   readonly sthis: SuperThis;
+//   readonly logger: Logger;
+//   readonly ende: EnDeCoder;
+//   readonly impl: HonoServerImpl;
+//   readonly wsRoom: WSRoom;
+// }
+
+export class WSContextWithId<T> extends WSContext<T> {
+  readonly id: string;
+  constructor(id: string, ws: WSContextInit<T>) {
+    super(ws);
+    this.id = id;
+  }
+}
+
+export interface ExposeCtxItem<T extends WSRoom> {
+  readonly sthis: SuperThis;
+  readonly port: number;
+  readonly wsRoom: T;
+  readonly logger: Logger;
+  readonly ende: ps.cloud.EnDeCoder;
+  readonly stsService: rt.sts.SessionTokenService;
+  readonly gestalt: ps.cloud.Gestalt;
+  readonly dbFactory: () => SQLDatabase;
+  // readonly metaMerger: MetaMerger;
+  readonly id: string;
+}
+
+export type ExposeCtxItemWithImpl<T extends WSRoom> = ExposeCtxItem<T> & { impl: HonoServerImpl };
+
+export interface WSEventsConnId<T> {
+  readonly onOpen: (evt: Event, ws: WSContextWithId<T>) => void;
+  readonly onMessage: (evt: MessageEvent<WSMessageReceive>, ws: WSContextWithId<T>) => void;
+  readonly onClose: (evt: CloseEvent, ws: WSContextWithId<T>) => void;
+  readonly onError: (evt: Event, ws: WSContextWithId<T>) => void;
+}
+
+// eslint-disable-next-line @typescript-eslint/no-invalid-void-type
+export type ConnMiddleware = (conn: WSConnectionPair, c: Context, next: Next) => Promise<Response | void>;
+export interface HonoServerImpl {
+  validateAuth(ctx: MsgDispatcherCtx, auth: ps.cloud.AuthType): Promise<Result<ps.cloud.FPCloudAuthType>>;
+
+  start<T extends WSRoom>(ctx: ExposeCtxItem<T>): Promise<HonoServerImpl>;
+  // gestalt(): Gestalt;
+  // getConnected(): Connected[];
+  calculatePreSignedUrl(msgCtx: MsgTypesCtx, p: PreSignedMsg): Promise<Result<URI>>;
+  upgradeWebSocket(createEvents: (c: Context) => WSEventsConnId<unknown> | Promise<WSEventsConnId<unknown>>): ConnMiddleware;
+  handleBindGetMeta(ctx: MsgDispatcherCtx, msg: BindGetMeta): Promise<MsgWithError<EventGetMeta>>;
+  handleReqPutMeta(ctx: MsgDispatcherCtx, msg: ReqPutMeta): Promise<MsgWithError<ResPutMeta>>;
+  handleReqDelMeta(ctx: MsgDispatcherCtx, msg: ReqDelMeta): Promise<MsgWithError<ResDelMeta>>;
+  // readonly headers: HttpHeader;
+}
+
+// export interface Connected {
+//   readonly connId: QSId
+//   readonly ws: WSContextWithId<T>;
+//   // readonly send: (msg: MsgBase) => Promisable<Response>;
+// }
+
+export abstract class HonoServerBase implements HonoServerImpl {
+  // readonly _gs: Gestalt;
+  // readonly sthis: SuperThis;
+  // readonly logger: Logger;
+  // readonly metaMerger: MetaMerger;
+  // readonly headers: HttpHeader;
+  // readonly wsRoom: WSRoom;
+  readonly id: string;
+  constructor(
+    id: string,
+    // sthis: SuperThis,
+    // logger: Logger,
+    // gs: Gestalt,
+    // sqlDb: SQLDatabase,
+    // wsRoom: WSRoom,
+    // headers?: HttpHeader
+  ) {
+    // this.logger = logger;
+    // this._gs = gs;
+    // this.sthis = sthis;
+    // this.wsRoom = wsRoom;
+    // this.metaMerger = new MetaMerger(id, sqlDb);
+    // this.headers = headers ? headers.Clone().Merge(CORS) : CORS.Clone();
+    this.id = id;
+    // console.log("HonoServerBase-ctor", this.id, sqlDb);
+  }
+
+  abstract upgradeWebSocket(
+    createEvents: (c: Context) => WSEventsConnId<unknown> | Promise<WSEventsConnId<unknown>>,
+  ): ConnMiddleware;
+
+  async validateAuth(ctx: MsgDispatcherCtx, auth: AuthType): Promise<Result<FPCloudAuthType>> {
+    if (!isAuthTypeFPCloudJWK(auth)) {
+      return Promise.resolve(Result.Err("Only fp-cloud-jwt is supported"));
+    }
+    // console.log("validateAuth-0", auth.params.jwk, ctx.stsService);
+    const rAuth = await ctx.stsService.validate(auth.params.jwk);
+    // console.log("validateAuth-1", auth.params.jwk, ctx.stsService, rAuth);
+    if (rAuth.isErr()) {
+      return Result.Err(rAuth);
+    }
+    return Result.Ok({
+      type: "fp-cloud",
+      params: {
+        claim: rAuth.Ok().payload,
+        jwk: auth.params.jwk,
+      },
+    });
+  }
+  // abstract getConnected(): Connected[];
+
+  start(ctx: ExposeCtxItem<WSRoom>, drop = false): Promise<HonoServerImpl> {
+    return metaMerger(ctx)
+      .createSchema(drop)
+      .then(() => this);
+  }
+
+  // gestalt(): Gestalt {
+  //   return this._gs;
+  // }
+
+  async handleReqPutMeta(ctx: MsgDispatcherCtx, msg: MsgWithConnAuth<ReqPutMeta>): Promise<MsgWithError<ResPutMeta>> {
+    const rUrl = await buildRes({ method: "PUT", store: "meta" }, "resPutMeta", ctx, msg, this);
+    if (MsgIsError(rUrl)) {
+      return rUrl;
+    }
+    await metaMerger(ctx).addMeta({
+      connection: msg,
+      meta: msg.meta,
+    });
+    return buildResPutMeta(ctx, msg, await metaMerger(ctx).metaToSend(msg), rUrl.signedUrl);
+  }
+
+  async handleReqDelMeta(ctx: MsgDispatcherCtx, msg: MsgWithConnAuth<ReqDelMeta>): Promise<MsgWithError<ResDelMeta>> {
+    const rUrl = await buildRes({ method: "DELETE", store: "meta" }, "resDelMeta", ctx, msg, this);
+    if (MsgIsError(rUrl)) {
+      return rUrl;
+    }
+    await metaMerger(ctx).delMeta({
+      connection: msg,
+      meta: msg.meta ?? { metas: [], keys: [] },
+    });
+    return buildResDelMeta(msg, rUrl.params, rUrl.signedUrl);
+  }
+
+  async handleBindGetMeta(
+    ctx: MsgDispatcherCtx,
+    msg: MsgWithConnAuth<BindGetMeta>,
+    gwCtx: GwCtx = msg,
+  ): Promise<MsgWithError<EventGetMeta>> {
+    const rMsg = await buildRes({ method: "GET", store: "meta" }, "eventGetMeta", ctx, msg, this);
+    if (MsgIsError(rMsg)) {
+      return rMsg;
+    }
+    // console.log("handleBindGetMeta-in", msg, this.id);
+    const meta = await metaMerger(ctx).metaToSend(msg);
+    // console.log("handleBindGetMeta-meta", meta);
+    const res = buildEventGetMeta(ctx, msg, meta, gwCtx, rMsg.signedUrl);
+    // console.log("handleBindGetMeta-out", res);
+    return res;
+  }
+
+  calculatePreSignedUrl(ctx: MsgTypesCtx, p: PreSignedMsg): Promise<Result<URI>> {
+    const rRes = ctx.sthis.env.gets({
+      STORAGE_URL: param.REQUIRED,
+      ACCESS_KEY_ID: param.REQUIRED,
+      SECRET_ACCESS_KEY: param.REQUIRED,
+      REGION: "us-east-1",
+    });
+    if (rRes.isErr()) {
+      return Promise.resolve(Result.Err(rRes.Err()));
+    }
+    const res = rRes.Ok();
+    return calculatePreSignedUrl(p, {
+      storageUrl: URI.from(res.STORAGE_URL),
+      aws: {
+        accessKeyId: res.ACCESS_KEY_ID,
+        secretAccessKey: res.SECRET_ACCESS_KEY,
+        region: res.REGION,
+      },
+    });
+  }
+}
+
+export interface HonoServerFactory<T extends WSRoom = WSRoom> {
+  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
+  inject(c: Context, fn: (rt: ExposeCtxItemWithImpl<T>) => Promise<Response | void>): Promise<Response | void>;
+
+  start(app: Hono): Promise<void>;
+  serve(app: Hono, port: number): Promise<void>;
+  close(): Promise<void>;
+}
+
+export const CORS = HttpHeader.from({
+  // "Accept": "application/json",
+  "Content-Type": "application/json",
+  "Access-Control-Allow-Origin": "*",
+  "Access-Control-Allow-Methods": "GET,POST,OPTIONS,PUT,DELETE",
+  "Access-Control-Max-Age": "86400", // Cache pre-flight response for 24 hours
+});
+
+class NoBackChannel implements MsgDispatcherCtx {
+  readonly ctx: ExposeCtxItemWithImpl<WSRoom>;
+  constructor(ctx: ExposeCtxItemWithImpl<WSRoom>) {
+    this.ctx = ctx;
+    this.impl = ctx.impl;
+    this.id = ctx.id;
+    this.port = ctx.port;
+    this.sthis = ctx.sthis;
+    this.logger = ctx.logger;
+    this.ende = ctx.ende;
+    this.gestalt = ctx.gestalt;
+    this.dbFactory = ctx.dbFactory;
+    this.stsService = ctx.stsService;
+  }
+  readonly impl: HonoServerImpl;
+  readonly port: number;
+  readonly sthis: SuperThis;
+  readonly logger: Logger;
+  readonly ende: ps.cloud.EnDeCoder;
+  readonly gestalt: ps.cloud.Gestalt;
+  readonly dbFactory: () => SQLDatabase;
+  readonly id: string;
+  readonly stsService: rt.sts.SessionTokenService;
+
+  get ws(): WSContextWithId<unknown> {
+    return {
+      id: "no-id",
+      send: (msg: string | ArrayBuffer | Uint8Array<ArrayBufferLike>): Promisable<Response> => {
+        return new Response(msg);
+      },
+    } as unknown as WSContextWithId<unknown>;
+  }
+  get wsRoom(): WSRoom {
+    return this.ctx.wsRoom;
+    // throw new Error("NoBackChannel:wsRoom Method not implemented.");
+  }
+}
+
+export class HonoServer {
+  // readonly sthis: SuperThis;
+  // readonly msgP: MsgerParams;
+  // readonly gestalt: Gestalt;
+  // readonly logger: Logger;
+  readonly factory: HonoServerFactory;
+  constructor(/* sthis: SuperThis, msgP: MsgerParams, gestalt: Gestalt, */ factory: HonoServerFactory) {
+    // this.sthis = sthis;
+    // this.logger = ensureLogger(sthis, "HonoServer");
+    // this.msgP = msgP;
+    // this.gestalt = gestalt;
+    this.factory = factory;
+  }
+
+  start(): Promise<HonoServer> {
+    return this.factory.start(new Hono()).then(() => this);
+  }
+
+  /* only for testing */
+  async once(app: Hono, port: number): Promise<HonoServer> {
+    this.register(app);
+    await this.factory.start(app);
+    await this.factory.serve(app, port);
+    return this;
+  }
+
+  async serve(app: Hono, port: number): Promise<HonoServer> {
+    await this.factory.serve(app, port);
+    return this;
+  }
+  // readonly _register = new ResolveOnce<HonoServer>();
+  register(app: Hono): HonoServer {
+    // return this._register.once(async () => {
+    // console.log("register-1");
+    //   await this.factory.start(app);
+    // console.log("register-2");
+    // app.put('/gestalt', async (c) => c.json(buildResGestalt(await c.req.json(), defaultGestaltItem({ id: "server", hasPersistent: true }).gestalt)))
+    // app.put('/error', async (c) => c.json(buildErrorMsg(sthis, sthis.logger, await c.req.json(), new Error("test error"))))
+    app.put("/fp", (c) =>
+      this.factory.inject(c, async (ctx) => {
+        Object.entries(c.req.header()).forEach(([k, v]) => c.res.headers.set(k, v[0]));
+        const rMsg = await exception2Result(() => c.req.json() as Promise<MsgBase>);
+        if (rMsg.isErr()) {
+          c.status(400);
+          return c.json(buildErrorMsg(ctx, { tid: "internal" }, rMsg.Err()));
+        }
+        const dispatcher = buildMsgDispatcher(ctx.sthis);
+        return dispatcher.dispatch(new NoBackChannel(ctx), rMsg.Ok());
+      }),
+    );
+    // console.log("register-2.1");
+    app.get("/ws", (c, next) =>
+      this.factory.inject(c, async (ctx) => {
+        // eslint-disable-next-line @typescript-eslint/no-unused-vars
+        return ctx.impl.upgradeWebSocket((_c) => {
+          let dp: MsgDispatcher;
+          // const id = ctx.sthis.nextId().str;
+          // console.log("upgradeWebSocket:inject:", id);
+          return {
+            // eslint-disable-next-line @typescript-eslint/no-unused-vars
+            onOpen: (_e, _ws) => {
+              dp = buildMsgDispatcher(ctx.sthis);
+              // console.log("onOpen:inject:", id);
+            },
+            onError: (error) => {
+              ctx.logger.Error().Err(error).Msg("WebSocket error");
+            },
+            onMessage: async (event, ws) => {
+              const rMsg = await exception2Result(async () => ctx.ende.decode(await top_uint8(event.data)) as MsgBase);
+              if (rMsg.isErr()) {
+                ws.send(
+                  ctx.ende.encode(
+                    buildErrorMsg(
+                      ctx,
+                      {
+                        message: event.data,
+                      } as ps.cloud.ErrorMsg,
+                      rMsg.Err(),
+                    ),
+                  ),
+                );
+              } else {
+                // console.log("dp-dispatch", rMsg.Ok(), dp);
+                await dp.dispatch({ ...ctx, ws }, rMsg.Ok());
+              }
+            },
+            // eslint-disable-next-line @typescript-eslint/no-unused-vars
+            onClose: (_evt, _ws) => {
+              // impl.delConn(ws);
+              // console.log("onClose:inject:", id);
+              dp = undefined as unknown as MsgDispatcher;
+              // console.log('Connection closed')
+            },
+          };
+        })(new WSConnectionPair(), c, next);
+      }),
+    );
+    return this;
+    // console.log("register-3");
+    // await this.factory.serve(app, port);
+    // console.log("register-4");
+    // return this;
+    // });
+  }
+  async close() {
+    const ret = await this.factory.close();
+    return ret;
+  }
+}
+
+// export async function honoServer(_sthis: SuperThis, _msgP: MsgerParams, _gestalt: Gestalt) {
+//   const rt = runtimeFn();
+//   if (rt.isNodeIsh) {
+//     // const { NodeHonoServer } = await import("./node-hono-server.js");
+//     // return new HonoServer(sthis, msgP, gestalt, new NodeHonoServer());
+//   }
+//   throw new Error("Not implemented");
+// }
+++ b/cloud-backend/meta-merger/abstract-sql.ts
+// import { RunResult } from "better-sqlite3";
+
+// export function now() {
+//   return new Date().toISOString();
+// }
+
+// export interface SqlLiteStmt {
+//   // eslint-disable-next-line @typescript-eslint/no-explicit-any
+//   bind(...args: any[]): any;
+//   // eslint-disable-next-line @typescript-eslint/no-explicit-any
+//   run(...args: any[]): Promise<RunResult>;
+//   // eslint-disable-next-line @typescript-eslint/no-explicit-any
+//   get<T>(...args: any[]): Promise<T>;
+// }
+
+// export interface SqlLite {
+//   prepare(sql: string): SqlLiteStmt;
+// }
+
+// export interface SqlLiteDBDialect {
+
+// }
+
+// export type SQLLiteFlavor = BaseSQLiteDatabase<'async', unknown>;
+
+export interface SQLDatabase {
+  prepare(sql: string): SQLStatement;
+}
+
+export type SQLParams = (string | number | Date)[];
+
+// export type SQLRow = Record<string, unknown>;
+
+export interface SQLStatement {
+  run<T = void>(...params: SQLParams): Promise<T>;
+  all<T>(...params: SQLParams): Promise<T[]>;
+}
+
+export function conditionalDrop(drop: boolean, tabName: string, create: string): string[] {
+  if (!drop) {
+    return [create];
+  }
+  return [`DROP TABLE IF EXISTS ${tabName}`, create];
+}
+
+export function sqliteCoerceParams(params: SQLParams): (string | number)[] {
+  return params.map((i) => {
+    if (i instanceof Date) {
+      return i.toISOString();
+    }
+    return i;
+  });
+}
+++ b/cloud-backend/meta-merger/bettersql-abstract-sql.ts
+import { SQLDatabase, sqliteCoerceParams, SQLParams, SQLStatement } from "./abstract-sql.js";
+
+import Database from "better-sqlite3";
+
+export class BetterSQLStatement implements SQLStatement {
+  readonly stmt: Database.Statement;
+  constructor(stmt: Database.Statement) {
+    this.stmt = stmt;
+  }
+
+  async run<T>(...iparams: SQLParams): Promise<T> {
+    const res = (await this.stmt.run(...sqliteCoerceParams(iparams))) as T;
+    // console.log("run", res);
+    return res;
+  }
+  async all<T>(...params: SQLParams): Promise<T[]> {
+    const res = (await this.stmt.all(...sqliteCoerceParams(params))) as T[];
+    // console.log("all", res);
+    return res;
+  }
+}
+
+export class BetterSQLDatabase implements SQLDatabase {
+  readonly db: Database.Database;
+  constructor(dbOrPath: Database.Database | string) {
+    if (typeof dbOrPath === "string") {
+      this.db = new Database(dbOrPath);
+    } else {
+      this.db = dbOrPath;
+    }
+  }
+
+  prepare(sql: string): SQLStatement {
+    const stmt = this.db.prepare(sql);
+    return new BetterSQLStatement(stmt);
+  }
+}
+++ b/cloud-backend/meta-merger/create-schema-cli.ts
+import { MetaSendSql } from "./meta-send.js";
+
+async function main() {
+  // eslint-disable-next-line no-console
+  console.log(MetaSendSql.schema(true).join(";\n"));
+}
+
+// eslint-disable-next-line no-console
+main().catch(console.error);
+++ b/cloud-backend/meta-merger/key-by-tenant-ledger.ts
+import { conditionalDrop, SQLDatabase, SQLStatement } from "./abstract-sql.js";
+import { ByConnection } from "./meta-merger.js";
+import { TenantLedgerSql } from "./tenant-ledger.js";
+
+export interface KeysForTenantLedger {
+  readonly tenant: string;
+  readonly ledger: string;
+  readonly keys: string[];
+  readonly createdAt: Date;
+}
+
+export interface SQLMetaByTenantLedgerRow {
+  readonly tenant: string;
+  readonly ledger: string;
+  readonly key: string;
+  readonly createdAt: string;
+}
+
+export class KeyByTenantLedgerSql {
+  static schema(drop = false) {
+    return [
+      ...conditionalDrop(
+        drop,
+        "KeyByTenantLedger",
+        `
+        CREATE TABLE IF NOT EXISTS KeyByTenantLedger(
+          tenant TEXT NOT NULL,
+          ledger TEXT NOT NULL,
+          key TEXT NOT NULL,
+          createdAt TEXT NOT NULL,
+          PRIMARY KEY (tenant, ledger, key),
+          FOREIGN KEY (tenant, ledger) REFERENCES TenantLedger(tenant, ledger)
+        )
+      `,
+      ),
+    ];
+  }
+
+  readonly db: SQLDatabase;
+  readonly tenantLedgerSql: TenantLedgerSql;
+  readonly id: string;
+  constructor(id: string, db: SQLDatabase, tenantLedgerSql: TenantLedgerSql) {
+    this.db = db;
+    this.tenantLedgerSql = tenantLedgerSql;
+    this.id = id;
+  }
+
+  // readonly #sqlCreateMetaByTenantLedger = new ResolveOnce();
+  sqlCreateKeyByTenantLedger(): SQLStatement[] {
+    // return this.#sqlCreateMetaByTenantLedger.once(() => {
+    return KeyByTenantLedgerSql.schema().map((i) => this.db.prepare(i));
+    // });
+  }
+
+  // readonly #sqlInsertMetaByTenantLedger = new ResolveOnce();
+  sqlEnsureKeyByTenantLedger(): SQLStatement {
+    // return this.#sqlInsertMetaByTenantLedger.once(() => {
+    return this.db.prepare(`
+          INSERT INTO KeyByTenantLedger(tenant, ledger, key, createdAt)
+            SELECT ?, ?, ?, ? WHERE NOT EXISTS (
+              SELECT 1 FROM KeyByTenantLedger WHERE key = ? and tenant = ? and ledger = ?
+            )
+        `);
+    // });
+  }
+
+  // readonly #sqlDeleteByConnection = new ResolveOnce();
+  sqlDeleteByTenantLedgerKey(): SQLStatement {
+    // return this.#sqlDeleteByConnection.once(() => {
+    return this.db.prepare(`
+          DELETE FROM KeyByTenantLedger
+            WHERE
+              tenant = ?
+            AND
+              ledger = ?
+            AND
+              key = ?
+        `);
+    // });
+  }
+
+  async deleteByTenantLedgerKey(t: Omit<KeysForTenantLedger, "createdAt">): Promise<void> {
+    const stmt = this.sqlDeleteByTenantLedgerKey();
+    for (const key of t.keys) {
+      await stmt.run(t.tenant, t.ledger, key);
+    }
+  }
+
+  async ensure(t: KeysForTenantLedger): Promise<void> {
+    const stmt = this.sqlEnsureKeyByTenantLedger();
+    for (const key of t.keys) {
+      await stmt.run(t.tenant, t.ledger, key, t.createdAt, key, t.tenant, t.ledger);
+    }
+  }
+
+  sqlSelectByTenantLedger(): SQLStatement {
+    return this.db.prepare(`
+          SELECT tenant, ledger, key, createdAt
+          FROM KeyByTenantLedger
+          WHERE tenant = ? AND ledger = ? 
+          ORDER BY key
+        `);
+  }
+
+  async selectKeysByTenantLedger(conn: ByConnection): Promise<Omit<KeysForTenantLedger, "createdAt">> {
+    const stmt = this.sqlSelectByTenantLedger();
+    const rows = await stmt.all<SQLMetaByTenantLedgerRow>(conn.tenant, conn.ledger);
+    return {
+      tenant: conn.tenant,
+      ledger: conn.ledger,
+      keys: rows.map((r) => r.key),
+    };
+  }
+}
+++ b/cloud-backend/meta-merger/meta-by-tenant-ledger.ts
+import { CRDTEntry } from "@fireproof/core";
+import { TenantLedgerSql } from "./tenant-ledger.js";
+import { ByConnection } from "./meta-merger.js";
+import { conditionalDrop, SQLDatabase, SQLStatement } from "./abstract-sql.js";
+
+export interface MetaByTenantLedgerRow {
+  readonly tenant: string;
+  readonly ledger: string;
+  readonly reqId: string;
+  readonly resId: string;
+  readonly metaCID: string;
+  readonly meta: CRDTEntry;
+  readonly updateAt: Date;
+}
+
+interface SQLMetaByTenantLedgerRow {
+  readonly tenant: string;
+  readonly ledger: string;
+  readonly reqId: string;
+  readonly resId: string;
+  readonly metaCID: string;
+  readonly meta: string;
+  readonly updateAt: string;
+}
+
+/*
+SELECT * FROM Mitarbeiter e1
+WHERE NOT EXISTS
+(
+    SELECT 1 FROM Mitarbeiter e2
+    WHERE e1.employee_id=e2.employee_id und e2.employee_name LIKE 'A%'
+);
+ */
+
+export class MetaByTenantLedgerSql {
+  static schema(drop = false) {
+    return [
+      ...TenantLedgerSql.schema(drop),
+      ...conditionalDrop(
+        drop,
+        "MetaByTenantLedger",
+        `
+      CREATE TABLE IF NOT EXISTS MetaByTenantLedger(
+        tenant TEXT NOT NULL,
+        ledger TEXT NOT NULL,
+        reqId TEXT NOT NULL,
+        resId TEXT NOT NULL,
+        metaCID TEXT NOT NULL,
+        meta  TEXT NOT NULL,
+        updatedAt TEXT NOT NULL,
+        PRIMARY KEY (tenant, ledger, reqId, resId, metaCID),
+        UNIQUE (tenant, ledger, metaCID),
+        FOREIGN KEY (tenant, ledger) REFERENCES TenantLedger(tenant, ledger)
+      )
+    `,
+      ),
+    ];
+  }
+
+  readonly db: SQLDatabase;
+  readonly tenantLedgerSql: TenantLedgerSql;
+  readonly id: string;
+  constructor(id: string, db: SQLDatabase, tenantLedgerSql: TenantLedgerSql) {
+    this.db = db;
+    this.tenantLedgerSql = tenantLedgerSql;
+    this.id = id;
+  }
+
+  // readonly #sqlCreateMetaByTenantLedger = new ResolveOnce();
+  sqlCreateMetaByTenantLedger(): SQLStatement[] {
+    // return this.#sqlCreateMetaByTenantLedger.once(() => {
+    return MetaByTenantLedgerSql.schema().map((i) => this.db.prepare(i));
+    // });
+  }
+
+  // readonly #sqlInsertMetaByTenantLedger = new ResolveOnce();
+  sqlEnsureMetaByTenantLedger(): SQLStatement {
+    // return this.#sqlInsertMetaByTenantLedger.once(() => {
+    return this.db.prepare(`
+        INSERT INTO MetaByTenantLedger(tenant, ledger, reqId, resId, metaCID, meta, updatedAt)
+          SELECT ?, ?, ?, ?, ?, ?, ? WHERE NOT EXISTS (
+            SELECT 1 FROM MetaByTenantLedger WHERE metaCID = ? AND tenant = ? AND ledger = ? 
+          )
+      `);
+    // });
+  }
+
+  // readonly #sqlDeleteByConnection = new ResolveOnce();
+  sqlDeleteByConnection(): SQLStatement {
+    // return this.#sqlDeleteByConnection.once(() => {
+    const stmt = this.db.prepare(`
+        DELETE FROM MetaByTenantLedger
+          WHERE
+            tenant = ?
+          AND
+            ledger = ?
+          AND
+            reqId = ?
+          AND
+            resId = ?
+          AND
+            metaCID NOT IN (SELECT value FROM json_each(?))
+      `);
+    return stmt;
+    // });
+  }
+
+  /*
+   * select * from MetaByTenantLedger where tenant = 'tenant' and ledger = 'ledger' group by metaCID
+   */
+
+  // readonly #sqlSelectByMetaCIDs = new ResolveOnce<Statement>()
+  // sqlSelectByMetaCIDs(): Statement<string[], SQLMetaByTenantLedgerRow> {
+  //   return this.#sqlSelectByMetaCIDs.once(() => {
+  //     return this.db.prepare(`
+  //       SELECT tenant, ledger, reqId, resId, metaCID, meta, updatedAt
+  //       FROM MetaByTenantLedger
+  //       WHERE metaCID in ?
+  //     `);
+  //   })
+  // }
+  // async selectByMetaCIDs(metaCIDs: string[]): Promise<MetaByTenantLedgerRow[]> {
+  //   const stmt = this.sqlSelectByMetaCIDs();
+  //   const rows = await stmt.all(metaCIDs)
+  //   return rows.map(row => ({
+  //     ...row,
+  //     meta: JSON.parse(row.meta),
+  //     updateAt: new Date(row.updateAt)
+  //   } satisfies MetaByTenantLedgerRow))
+  // }
+
+  async deleteByConnection(t: ByConnection, waitingMetaCIDS: string[]) {
+    const stmt = this.sqlDeleteByConnection();
+    // console.log("deleteByConnection:by:", t);
+    return stmt.run(t.tenant, t.ledger, t.reqId, t.resId, JSON.stringify(waitingMetaCIDS));
+  }
+
+  async ensure(t: MetaByTenantLedgerRow) {
+    const stmt = this.sqlEnsureMetaByTenantLedger();
+    return stmt.run(
+      t.tenant,
+      t.ledger,
+      t.reqId,
+      t.resId,
+      t.metaCID,
+      JSON.stringify(t.meta),
+      t.updateAt,
+      t.metaCID,
+      t.tenant,
+      t.ledger,
+    );
+  }
+
+  sqlSelectByConnection(): SQLStatement {
+    return this.db.prepare(`
+        SELECT tenant, ledger, reqId, resId, metaCID, meta, updatedAt
+        FROM MetaByTenantLedger
+        WHERE tenant = ? AND ledger = ? AND reqId = ? AND resId = ?
+        ORDER BY updatedAt
+      `);
+  }
+
+  async selectByConnection(conn: ByConnection): Promise<MetaByTenantLedgerRow[]> {
+    const stmt = this.sqlSelectByConnection();
+    const rows = await stmt.all<SQLMetaByTenantLedgerRow>(conn.tenant, conn.ledger, conn.reqId, conn.resId);
+    return rows.map(
+      (row) =>
+        ({
+          ...row,
+          meta: JSON.parse(row.meta),
+          updateAt: new Date(row.updateAt),
+        }) satisfies MetaByTenantLedgerRow,
+    );
+  }
+}
+++ b/cloud-backend/meta-merger/meta-merger.test.ts
+// import type { Database } from "better-sqlite3";
+import { Connection, MetaMerge, MetaMerger } from "./meta-merger.js";
+import { ensureSuperThis } from "@fireproof/core";
+import { SQLDatabase } from "./abstract-sql.js";
+import { V2SerializedMetaKey } from "../../src/runtime/meta-key-hack.js";
+
+function sortCRDTEntries(rows: V2SerializedMetaKey) {
+  return rows.metas.sort((a, b) => a.cid.localeCompare(b.cid));
+}
+
+function sortKeysEntries(rows: V2SerializedMetaKey) {
+  return rows.keys.sort();
+}
+
+interface MetaConnection {
+  readonly meta: V2SerializedMetaKey;
+  readonly connection: Connection;
+}
+
+function toCRDTEntries(rows: MetaConnection[]) {
+  return rows.reduce(
+    (r, i) => {
+      r.metas.push(...i.meta.metas);
+      r.keys.push(...i.meta.keys);
+      return r;
+    },
+    {
+      metas: [],
+      keys: [],
+    } as V2SerializedMetaKey,
+  );
+}
+
+// function filterConnection(ref: MetaConnection[], connection: Connection) {
+//   return toCRDTEntries(ref.filter((r) =>
+//       (r.connection.tenant.tenant === connection.tenant.tenant &&
+//       r.connection.tenant.ledger === connection.tenant.ledger &&
+//       r.connection.conn.reqId === connection.conn.reqId &&
+//       r.connection.conn.resId === connection.conn.resId)))
+// }
+
+function getSQLFlavours(): { name: string; factory: () => Promise<SQLDatabase> }[] {
+  return [
+    {
+      name: "bettersql",
+      factory: async () => {
+        const { BetterSQLDatabase } = await import("./bettersql-abstract-sql.js");
+        return new BetterSQLDatabase("./dist/test.db");
+      },
+    },
+  ];
+}
+
+describe.each(getSQLFlavours())("$name - MetaMerger", (flavour) => {
+  // let db: SQLDatabase;
+  const sthis = ensureSuperThis();
+  const logger = sthis.logger;
+  let mm: MetaMerger;
+  beforeAll(async () => {
+    //    db = new Database(':memory:');
+    const db = await flavour.factory();
+    mm = new MetaMerger("bong", logger, db);
+    await mm.createSchema();
+  });
+
+  let metaMerge: MetaMerge;
+  beforeEach(() => {
+    metaMerge = {
+      connection: {
+        tenant: {
+          tenant: `tenant${sthis.timeOrderedNextId().str}`,
+          ledger: "ledger",
+        },
+        conn: {
+          reqId: "reqId",
+          resId: `resId-${sthis.timeOrderedNextId().str}`,
+        },
+      },
+      meta: {
+        metas: [],
+        keys: [],
+      },
+    } satisfies MetaMerge;
+  });
+
+  afterEach(async () => {
+    await mm.delMeta(metaMerge);
+  });
+
+  it("insert nothing", async () => {
+    await mm.addMeta({
+      ...metaMerge,
+      meta: {
+        metas: [],
+        keys: [],
+      },
+      now: new Date(),
+    });
+    const rows = await mm.metaToSend(metaMerge.connection);
+    expect(rows).toEqual({
+      metas: [],
+      keys: [],
+    });
+  });
+
+  it("insert one multiple", async () => {
+    const cid = sthis.timeOrderedNextId().str;
+    for (let i = 0; i < 10; i++) {
+      const meta = {
+        metas: Array(i).fill({
+          cid,
+          parents: [],
+          data: "MomRkYXRho",
+        }),
+        keys: Array(i).fill("key"),
+      };
+      // console.log("metas", i, metas);
+      await mm.addMeta({
+        ...metaMerge,
+        meta,
+        now: new Date(),
+      });
+      const rows = await mm.metaToSend(metaMerge.connection);
+      if (i === 1) {
+        expect(rows).toEqual(meta);
+      } else {
+        expect(rows).toEqual({
+          metas: [],
+          keys: i ? ["key"] : [],
+        });
+      }
+    }
+  });
+
+  it("insert multiple", async () => {
+    const conns = [];
+    const keys = [] as string[];
+    for (let i = 0; i < 10; i++) {
+      const meta = {
+        metas: Array(i)
+          .fill({
+            cid: "x",
+            parents: [],
+            data: "MomRkYXRho",
+          })
+          .map((m) => ({ ...m, cid: sthis.timeOrderedNextId().str })),
+        keys: Array(i)
+          .fill("key")
+          .map(() => sthis.timeOrderedNextId().str),
+      };
+      const conn = {
+        ...metaMerge.connection,
+        reqId: sthis.timeOrderedNextId().str,
+      };
+      conns.push(conn);
+      await mm.addMeta({
+        ...metaMerge,
+        meta,
+        now: new Date(),
+      });
+      const rows = await mm.metaToSend(metaMerge.connection);
+      expect(sortCRDTEntries(rows)).toEqual(sortCRDTEntries(meta));
+      keys.push(...meta.keys);
+      expect(sortKeysEntries(rows)).toEqual(keys.sort());
+    }
+    await Promise.all(
+      conns.map(async (conn) =>
+        mm.delMeta({
+          connection: conn,
+          meta: {
+            metas: [],
+            keys: [],
+          },
+        }),
+      ),
+    );
+  });
+
+  it("metaToSend to sink", async () => {
+    const connections = Array(2)
+      .fill(metaMerge.connection)
+      .map((c) => ({ ...c, conn: { ...c.conn, reqId: sthis.timeOrderedNextId().str } }));
+    const ref: MetaConnection[] = [];
+    for (const connection of connections) {
+      const meta = {
+        metas: Array(2)
+          .fill({
+            cid: "x",
+            parents: [],
+            data: "MomRkYXRho",
+          })
+          .map((m) => ({ ...m, cid: sthis.timeOrderedNextId().str })),
+        keys: Array(2)
+          .fill("key")
+          .map(() => sthis.timeOrderedNextId().str),
+      };
+      ref.push({ meta, connection });
+      await mm.addMeta({
+        connection,
+        meta,
+        now: new Date(),
+      });
+    }
+    // wrote 10 connections with 3 metas each
+    for (const connection of connections) {
+      const rows = await mm.metaToSend(connection);
+      expect(sortCRDTEntries(rows)).toEqual(sortCRDTEntries(toCRDTEntries(ref)));
+      const rowsEmpty = await mm.metaToSend(connection);
+      expect(sortCRDTEntries(rowsEmpty)).toEqual([]);
+    }
+    const newConnections = Array(2)
+      .fill(metaMerge.connection)
+      .map((c) => ({ ...c, conn: { ...c.conn, reqId: sthis.timeOrderedNextId().str } }));
+    for (const connection of newConnections) {
+      const rows = await mm.metaToSend(connection);
+      expect(sortCRDTEntries(rows)).toEqual(sortCRDTEntries(toCRDTEntries(ref)));
+      expect(sortKeysEntries(rows)).toEqual(sortKeysEntries(toCRDTEntries(ref)));
+      const rowsEmpty = await mm.metaToSend(connection);
+      expect(sortCRDTEntries(rowsEmpty)).toEqual([]);
+    }
+    await Promise.all(
+      connections.map(async (connection) =>
+        mm.delMeta({
+          connection,
+          meta: {
+            metas: [],
+            keys: [],
+          },
+        }),
+      ),
+    );
+  });
+
+  it("delMeta", async () => {
+    await mm.addMeta({
+      ...metaMerge,
+      meta: {
+        metas: [
+          {
+            cid: `del-${sthis.timeOrderedNextId().str}`,
+            parents: [],
+            data: "MomRkYXRho",
+          },
+          {
+            cid: `del-${sthis.timeOrderedNextId().str}`,
+            parents: [],
+            data: "MomRkYXRho",
+          },
+        ],
+        keys: ["hello", "world"],
+      },
+      now: new Date(),
+    });
+    const rows = await mm.metaToSend(metaMerge.connection);
+    expect(rows.metas.length).toBe(2);
+    expect(rows.keys.length).toBe(2);
+    await mm.delMeta({
+      connection: metaMerge.connection,
+      meta: rows,
+      now: new Date(),
+    });
+    const rowsDel = await mm.metaToSend(metaMerge.connection);
+    expect(rowsDel.metas.length).toBe(0);
+    expect(rowsDel.keys.length).toBe(0);
+  });
+});
+++ b/cloud-backend/meta-merger/meta-merger.ts
+import { ps } from "@fireproof/core";
+import { MetaByTenantLedgerSql } from "./meta-by-tenant-ledger.js";
+import { MetaSendSql } from "./meta-send.js";
+import { TenantLedgerSql } from "./tenant-ledger.js";
+import { TenantSql } from "./tenant.js";
+import { SQLDatabase } from "./abstract-sql.js";
+import { Logger } from "@adviser/cement";
+import { V2SerializedMetaKey } from "../../src/runtime/meta-key-hack.js";
+import { KeyByTenantLedgerSql } from "./key-by-tenant-ledger.js";
+
+type TenantLedger = ps.cloud.TenantLedger;
+type QSId = ps.cloud.QSId;
+
+export interface Connection {
+  readonly tenant: TenantLedger;
+  readonly conn: QSId;
+}
+
+export interface MetaMerge {
+  // readonly logger Logger;
+  readonly connection: Connection;
+  readonly meta: V2SerializedMetaKey;
+  readonly now?: Date;
+}
+
+export interface ByConnection {
+  readonly tenant: string;
+  readonly ledger: string;
+  readonly reqId: string;
+  readonly resId: string;
+}
+
+function toByConnection(connection: Connection): ByConnection {
+  return {
+    ...connection.conn,
+    ...connection.tenant,
+  };
+}
+
+export function metaMerger(ctx: {
+  readonly id: string;
+  readonly logger: Logger;
+  readonly dbFactory: () => SQLDatabase;
+  // readonly sthis: SuperThis;
+}) {
+  return new MetaMerger(ctx.id, ctx.logger, ctx.dbFactory());
+}
+
+export class MetaMerger {
+  readonly db: SQLDatabase;
+  // readonly sthis: SuperThis;
+  readonly sql: {
+    readonly tenant: TenantSql;
+    readonly tenantLedger: TenantLedgerSql;
+    readonly metaByTenantLedger: MetaByTenantLedgerSql;
+    readonly keyByTenantLedger: KeyByTenantLedgerSql;
+    readonly metaSend: MetaSendSql;
+  };
+
+  readonly logger: Logger;
+  readonly id: string;
+
+  constructor(id: string, logger: Logger, db: SQLDatabase) {
+    this.db = db;
+    this.id = id;
+    this.logger = logger;
+    // this.sthis = sthis;
+    const tenant = new TenantSql(id, db);
+    const tenantLedger = new TenantLedgerSql(id, db, tenant);
+    this.sql = {
+      tenant,
+      tenantLedger,
+      metaByTenantLedger: new MetaByTenantLedgerSql(id, db, tenantLedger),
+      keyByTenantLedger: new KeyByTenantLedgerSql(id, db, tenantLedger),
+      metaSend: new MetaSendSql(id, db),
+    };
+  }
+
+  async createSchema(drop = false) {
+    for (const i of this.sql.metaSend.sqlCreateMetaSend(drop)) {
+      await i.run();
+    }
+  }
+
+  async delMeta(mm: MetaMerge): Promise<{ now: Date; byConnection: ByConnection }> {
+    const now = mm.now || new Date();
+    const byConnection = toByConnection(mm.connection);
+    const metaCIDs = mm.meta.metas.map((meta) => meta.cid);
+    const connCIDs = {
+      ...byConnection,
+      metaCIDs: metaCIDs,
+    };
+    // console.log("delMeta", mm);
+    await this.sql.keyByTenantLedger.deleteByTenantLedgerKey({
+      ...byConnection,
+      keys: mm.meta.keys,
+    });
+
+    await this.sql.metaSend.deleteByConnection(connCIDs);
+    const waitingMetaCIDS = await this.sql.metaSend.getToSendMetaCIDs(byConnection.tenant, byConnection.ledger);
+    await this.sql.metaByTenantLedger.deleteByConnection(connCIDs, waitingMetaCIDS);
+    return { now, byConnection };
+  }
+
+  async addMeta(mm: MetaMerge) {
+    if (!mm.meta.metas.length) {
+      return;
+    }
+    const { now, byConnection } = await this.delMeta(mm);
+    await this.sql.tenantLedger.ensure({
+      ...mm.connection.tenant,
+      createdAt: now,
+    });
+    await this.sql.keyByTenantLedger.ensure({
+      ...byConnection,
+      keys: mm.meta.keys,
+      createdAt: now,
+    });
+    // console.log("addMeta", byConnection, mm.meta);
+    for (const meta of mm.meta.metas) {
+      try {
+        // console.log("addMeta", byConnection, meta);
+        await this.sql.metaByTenantLedger.ensure({
+          ...byConnection,
+          metaCID: meta.cid,
+          meta: meta,
+          updateAt: now,
+        });
+      } catch (e) {
+        this.logger.Error().Err(e).Str("metaCID", meta.cid).Msg("addMeta");
+      }
+    }
+  }
+
+  async metaToSend(sink: Connection, now = new Date()): Promise<V2SerializedMetaKey> {
+    const bySink = toByConnection(sink);
+    const rows = await this.sql.metaSend.selectToAddSend({ ...bySink, now });
+    // console.log("metaToSend", bySink, rows);
+    if (rows.length) {
+      await this.sql.metaSend.insert(
+        rows.map((row) => ({
+          metaCID: row.metaCID,
+          tenant: row.tenant,
+          ledger: row.ledger,
+          reqId: row.reqId,
+          resId: row.resId,
+          sendAt: row.sendAt,
+        })),
+      );
+    }
+    const { keys } = await this.sql.keyByTenantLedger.selectKeysByTenantLedger(bySink);
+    return {
+      keys,
+      metas: rows.map((row) => row.meta),
+    };
+  }
+}
+++ b/cloud-backend/meta-merger/meta-send.ts
+// import { ResolveOnce } from "@adviser/cement";
+import { MetaByTenantLedgerSql } from "./meta-by-tenant-ledger.js";
+import { ByConnection } from "./meta-merger.js";
+import { CRDTEntry } from "@fireproof/core";
+import { conditionalDrop, SQLDatabase, SQLStatement } from "./abstract-sql.js";
+import { KeyByTenantLedgerSql } from "./key-by-tenant-ledger.js";
+
+export interface MetaSendRow {
+  readonly metaCID: string;
+  readonly tenant: string;
+  readonly ledger: string;
+  readonly reqId: string;
+  readonly resId: string;
+  readonly sendAt: Date;
+}
+
+type SQLMetaSendRowWithMeta = MetaSendRow & { meta: string };
+export type MetaSendRowWithMeta = MetaSendRow & { meta: CRDTEntry };
+
+export class MetaSendSql {
+  static schema(drop = false) {
+    return [
+      ...MetaByTenantLedgerSql.schema(drop),
+      ...KeyByTenantLedgerSql.schema(drop),
+      ...conditionalDrop(
+        drop,
+        "MetaSend",
+        `
+      CREATE TABLE IF NOT EXISTS MetaSend (
+        metaCID TEXT NOT NULL,
+        tenant TEXT NOT NULL,
+        ledger TEXT NOT NULL,
+        reqId TEXT NOT NULL,
+        resId TEXT NOT NULL,
+        sendAt TEXT NOT NULL,
+        PRIMARY KEY(metaCID, tenant, ledger, reqId,resId),
+        FOREIGN KEY(tenant, ledger, metaCID) REFERENCES MetaByTenantLedger(tenant, ledger, metaCID)
+      );
+    `,
+      ),
+    ];
+  }
+
+  readonly db: SQLDatabase;
+  readonly id: string;
+  constructor(id: string, db: SQLDatabase) {
+    this.db = db;
+    this.id = id;
+  }
+
+  // readonly #sqlCreateMetaSend = new ResolveOnce<SQLStatement>();
+  sqlCreateMetaSend(drop: boolean): SQLStatement[] {
+    // return this.#sqlCreateMetaSend.once(() => {
+    return MetaSendSql.schema(drop).map((i) => this.db.prepare(i));
+    // });
+  }
+
+  // readonly #sqlInsertMetaSend = new ResolveOnce<SQLStatement>();
+  sqlInsertMetaSend(): SQLStatement {
+    // return this.#sqlInsertMetaSend.once(() => {
+    return this.db.prepare(`
+        INSERT INTO MetaSend(metaCID, tenant, ledger, reqId, resId, sendAt) VALUES(?, ?, ?, ?, ?, ?)
+      `);
+    // });
+  }
+
+  // readonly #sqlSelectToAddSend = new ResolveOnce<SQLStatement>();
+  sqlSelectToAddSend(): SQLStatement {
+    // return this.#sqlSelectToAddSend.once(() => {
+    return this.db.prepare(`
+        SELECT t.metaCID, t.tenant, t.ledger, ? as reqId, ? as resId, ? as sendAt, t.meta FROM MetaByTenantLedger as t
+          WHERE
+            t.tenant = ?
+          AND
+            t.ledger = ?
+          AND
+            NOT EXISTS (SELECT 1 FROM MetaSend AS s WHERE t.metaCID = s.metaCID and t.tenant = s.tenant and t.ledger = s.ledger and s.reqId = ? and s.resId = ?)
+      `);
+    // });
+  }
+
+  async selectToAddSend(conn: ByConnection & { now: Date }): Promise<MetaSendRowWithMeta[]> {
+    // console.log("selectToAddSend-1");
+    const stmt = this.sqlSelectToAddSend();
+    // console.log("selectToAddSend-2");
+    try {
+      const rows = await stmt.all<SQLMetaSendRowWithMeta>(
+        conn.reqId,
+        conn.resId,
+        conn.now,
+        conn.tenant,
+        conn.ledger,
+        conn.reqId,
+        conn.resId,
+      );
+      // console.log("selectToAddSend-3", rows);
+      return rows.map(
+        (i) =>
+          ({
+            metaCID: i.metaCID,
+            tenant: i.tenant,
+            ledger: i.ledger,
+            reqId: i.reqId,
+            resId: i.resId,
+            sendAt: new Date(i.sendAt),
+            meta: JSON.parse(i.meta) as CRDTEntry,
+          }) satisfies MetaSendRowWithMeta,
+      );
+    } catch (e) {
+      // eslint-disable-next-line no-console
+      console.error("selectToAddSend:error", this.id, e);
+      throw e;
+    }
+  }
+
+  async insert(t: MetaSendRow[]) {
+    const stmt = this.sqlInsertMetaSend();
+    for (const i of t) {
+      await stmt.run(i.metaCID, i.tenant, i.ledger, i.reqId, i.resId, i.sendAt);
+    }
+  }
+
+  sqlMetaCIDByConnection(): SQLStatement {
+    return this.db.prepare(`
+      SELECT metaCID FROM MetaSend
+      WHERE
+        tenant = ?
+      AND
+        ledger = ?
+      AND
+        reqId = ?
+      AND
+        resId = ?
+      AND
+        metaCID NOT IN (SELECT value FROM json_each(?))
+    `);
+  }
+  // readonly #sqlDeleteByConnection = new ResolveOnce<SQLStatement>();
+  sqlDeleteByMetaCID(): SQLStatement {
+    // return this.#sqlDeleteByConnection.once(() => {
+
+    return this.db.prepare(`
+      DELETE FROM MetaSend 
+        WHERE 
+          tenant = ? 
+        AND 
+          ledger = ? 
+        AND 
+          reqId = ? 
+        AND 
+          resId = ? 
+        AND 
+          metaCID in (SELECT value FROM json_each(?))
+      `);
+    // });
+  }
+
+  sqlMetaCIDByTenantLedger(): SQLStatement {
+    return this.db.prepare(`
+      select distinct metaCID from MetaSend where tenant = ? and ledger = ?
+    `);
+  }
+
+  async getToSendMetaCIDs(tenant: string, ledger: string): Promise<string[]> {
+    const stmt = this.sqlMetaCIDByTenantLedger();
+    const rows = await stmt.all<{ metaCID: string }>(tenant, ledger);
+    return rows.map((i) => i.metaCID);
+  }
+
+  async deleteByConnection(dmi: ByConnection & { metaCIDs: string[] }) {
+    const metaCIDs = await this.sqlMetaCIDByConnection().all<{ metaCID: string }>(
+      dmi.tenant,
+      dmi.ledger,
+      dmi.reqId,
+      dmi.resId,
+      JSON.stringify(dmi.metaCIDs),
+    );
+    if (!metaCIDs.length) {
+      return;
+    }
+    // console.log("deleteByConnection:send", dmi, metaCIDs);
+    const stmt = this.sqlDeleteByMetaCID();
+    return stmt.run(dmi.tenant, dmi.ledger, dmi.reqId, dmi.resId, JSON.stringify(metaCIDs.map((i) => i.metaCID)));
+  }
+}
+++ b/cloud-backend/meta-merger/tenant-ledger.ts
+// import { ResolveOnce } from "@adviser/cement";
+import { conditionalDrop, SQLDatabase, SQLStatement } from "./abstract-sql.js";
+import { TenantSql } from "./tenant.js";
+
+export interface TenantLedgerRow {
+  readonly tenant: string;
+  readonly ledger: string;
+  readonly createdAt: Date;
+}
+
+export class TenantLedgerSql {
+  static schema(drop = false) {
+    return [
+      ...TenantSql.schema(drop),
+      ...conditionalDrop(
+        drop,
+        "TenantLedger",
+        `
+      CREATE TABLE IF NOT EXISTS TenantLedger(
+        tenant TEXT NOT NULL,
+        ledger TEXT NOT NULL,
+        createdAt TEXT NOT NULL,
+        PRIMARY KEY(tenant, ledger),
+        FOREIGN KEY(tenant) REFERENCES Tenant(tenant)
+      )
+    `,
+      ),
+    ];
+  }
+
+  readonly db: SQLDatabase;
+  readonly tenantSql: TenantSql;
+  readonly id: string;
+  constructor(id: string, db: SQLDatabase, tenantSql: TenantSql) {
+    this.db = db;
+    this.tenantSql = tenantSql;
+    this.id = id;
+  }
+
+  // readonly #sqlCreateTenantLedger = new ResolveOnce<SQLStatement[]>();
+  sqlCreateTenantLedger(): SQLStatement[] {
+    // return this.#sqlCreateTenantLedger.once(() => {
+    return TenantLedgerSql.schema().map((i) => this.db.prepare(i));
+    // });
+  }
+
+  // readonly #sqlInsertTenantLedger = new ResolveOnce<SQLStatement>();
+  sqlEnsureTenantLedger(): SQLStatement {
+    // return this.#sqlInsertTenantLedger.once(() => {
+    return this.db.prepare(`
+        INSERT INTO TenantLedger(tenant, ledger, createdAt)
+          SELECT ?, ?, ? WHERE
+            NOT EXISTS(SELECT 1 FROM TenantLedger WHERE tenant = ? and ledger = ?)
+      `);
+    // });
+  }
+
+  async ensure(t: TenantLedgerRow) {
+    await this.tenantSql.ensure({ tenant: t.tenant, createdAt: t.createdAt });
+    const stmt = this.sqlEnsureTenantLedger();
+    const ret = stmt.run(t.tenant, t.ledger, t.createdAt, t.tenant, t.ledger);
+    return ret;
+  }
+}
+++ b/cloud-backend/meta-merger/tenant.ts
+// import { ResolveOnce } from "@adviser/cement";
+import { conditionalDrop, SQLDatabase, SQLStatement } from "./abstract-sql.js";
+
+export interface TenantRow {
+  readonly tenant: string;
+  readonly createdAt: Date;
+}
+
+export class TenantSql {
+  static schema(drop = false): string[] {
+    return [
+      ...conditionalDrop(
+        drop,
+        "Tenant",
+        `
+      CREATE TABLE IF NOT EXISTS Tenant(
+        tenant TEXT NOT NULL PRIMARY KEY,
+        createdAt TEXT NOT NULL
+      )
+    `,
+      ),
+    ];
+  }
+
+  readonly db: SQLDatabase;
+  readonly id: string;
+  constructor(id: string, db: SQLDatabase) {
+    this.db = db;
+    this.id = id;
+  }
+
+  // readonly #sqlCreateTenant = new ResolveOnce<SQLStatement[]>();
+  sqlCreateTenant(): SQLStatement[] {
+    // return this.#sqlCreateTenant.once(() => {
+    return TenantSql.schema().map((i) => this.db.prepare(i));
+    // });
+  }
+
+  // readonly #sqlInsertTenant = new ResolveOnce<SQLStatement>();
+  sqlEnsureTenant(): SQLStatement {
+    // return this.#sqlInsertTenant.once(() => {
+    return this.db.prepare(`
+        INSERT INTO Tenant(tenant, createdAt)
+          SELECT ?, ? WHERE NOT EXISTS(SELECT 1 FROM Tenant WHERE tenant = ?)
+      `);
+    // });
+  }
+
+  async ensure(t: TenantRow) {
+    const stmt = this.sqlEnsureTenant();
+    return stmt.run(t.tenant, t.createdAt, t.tenant);
+  }
+}
+++ b/cloud-backend/msg-dispatch.ts
+import { SuperThis, UnReg, ps, rt } from "@fireproof/core";
+
+import { ExposeCtxItemWithImpl, HonoServerImpl, WSContextWithId } from "./hono-server.js";
+import { WSRoom } from "./ws-room.js";
+
+type MsgBase = ps.cloud.MsgBase;
+type MsgWithError<T extends MsgBase> = ps.cloud.MsgWithError<T>;
+type QSId = ps.cloud.QSId;
+type MsgWithConnAuth<T extends MsgBase> = ps.cloud.MsgWithConnAuth<T>;
+type FPJWKCloudAuthType = ps.cloud.FPJWKCloudAuthType;
+type AuthType = ps.cloud.AuthType;
+type PreSignedMsg = ps.cloud.PreSignedMsg;
+const { buildErrorMsg, isAuthTypeFPCloud, MsgIsError, isAuthTypeFPCloudJWK } = ps.cloud;
+
+export interface MsgContext {
+  calculatePreSignedUrl(p: PreSignedMsg): Promise<string>;
+}
+
+export interface WSPair {
+  readonly client: WebSocket;
+  readonly server: WebSocket;
+}
+
+export class WSConnectionPair {
+  wspair?: WSPair;
+
+  attachWSPair(wsp: WSPair) {
+    if (!this.wspair) {
+      this.wspair = wsp;
+    } else {
+      throw new Error("wspair already set");
+    }
+  }
+}
+
+export type Promisable<T> = T | Promise<T>;
+
+// function WithValidConn<T extends MsgBase>(msg: T, rri?: ResOpen): msg is MsgWithConn<T> {
+//   return MsgIsWithConn(msg) && !!rri && rri.conn.resId === msg.conn.resId && rri.conn.reqId === msg.conn.reqId;
+// }
+
+export interface ConnItem<T = unknown> {
+  readonly conn: QSId;
+  touched: Date;
+  readonly ws: WSContextWithId<T>;
+}
+
+// const connManager = new ConnectionManager();
+
+export interface ConnectionInfo {
+  readonly conn: WSConnectionPair;
+  readonly reqId: string;
+  readonly resId: string;
+}
+
+export interface MsgDispatcherCtx extends ExposeCtxItemWithImpl<WSRoom> {
+  readonly id: string;
+  readonly impl: HonoServerImpl;
+  readonly stsService: rt.sts.SessionTokenService;
+  // readonly auth: AuthFactory;
+  readonly ws: WSContextWithId<unknown>;
+}
+
+export interface MsgDispatchItem<S extends MsgBase, Q extends MsgBase> {
+  readonly match: (msg: MsgBase) => boolean;
+  readonly isNotConn?: boolean;
+  fn(ctx: MsgDispatcherCtx, msg: Q): Promisable<MsgWithError<S>>;
+}
+
+export class MsgDispatcher {
+  readonly sthis: SuperThis;
+  // readonly logger: Logger;
+  // // wsConn?: WSConnection;
+  // readonly gestalt: Gestalt;
+  readonly id: string;
+  // readonly ende: EnDeCoder;
+
+  // // readonly connManager = connManager;
+
+  // readonly wsRoom: WSRoom;
+
+  static new(sthis: SuperThis /*, gestalt: Gestalt, ende: EnDeCoder, wsRoom: WSRoom*/): MsgDispatcher {
+    return new MsgDispatcher(sthis /*, gestalt, ende, wsRoom*/);
+  }
+
+  private constructor(sthis: SuperThis /*, gestalt: Gestalt, ende: EnDeCoder, wsRoom: WSRoom*/) {
+    this.sthis = sthis;
+    // this.logger = ensureLogger(sthis, "Dispatcher");
+    // this.gestalt = gestalt;
+    this.id = sthis.nextId().str;
+    // this.ende = ende;
+    // this.wsRoom = wsRoom;
+  }
+
+  // addConn(msg: MsgBase): Result<QSId> {
+  //   if (!MsgIsReqOpenWithConn(msg)) {
+  //     return this.logger.Error().Msg("msg missing reqId").ResultError();
+  //   }
+  //   return Result.Ok(connManager.addConn(msg.conn));
+  // }
+
+  readonly items = new Map<string, MsgDispatchItem<MsgBase, MsgBase>>();
+  registerMsg(...iItems: MsgDispatchItem<MsgBase, MsgBase>[]): UnReg {
+    const items = iItems.flat();
+    const ids: string[] = items.map((item) => {
+      const id = this.sthis.nextId(12).str;
+      this.items.set(id, item);
+      return id;
+    });
+    return () => ids.forEach((id) => this.items.delete(id));
+  }
+
+  send(ctx: MsgDispatcherCtx, msg: MsgBase) {
+    const isError = MsgIsError(msg);
+    const str = ctx.ende.encode(msg);
+    ctx.ws.send(str);
+    return new Response(str, {
+      status: isError ? 500 : 200,
+      statusText: isError ? "error" : "ok",
+    });
+  }
+
+  async validateConn<T extends MsgBase>(
+    ctx: MsgDispatcherCtx,
+    msg: T,
+    fn: (msg: MsgWithConnAuth<T>) => Promisable<MsgWithError<MsgBase>>,
+  ): Promise<Response> {
+    if (!ctx.wsRoom.isConnected(msg)) {
+      return this.send(ctx, buildErrorMsg(ctx, { ...msg }, new Error("dispatch missing connection")));
+      // return send(buildErrorMsg(this.sthis, this.logger, msg, new Error("non open connection")));
+    }
+    // console.log("validateConn-1");
+    const r = await this.validateAuth(ctx, msg, (msg) => fn(msg));
+    return Promise.resolve(this.send(ctx, r));
+  }
+
+  async validateAuth<T extends MsgBase>(
+    ctx: MsgDispatcherCtx,
+    msg: T,
+    fn: (msg: T) => Promisable<MsgWithError<MsgBase>>,
+  ): Promise<MsgWithError<MsgBase>> {
+    if (msg.auth) {
+      // console.log("validateAuth-1", msg.auth);
+      const rAuth = await ctx.impl.validateAuth(ctx, msg.auth);
+      if (rAuth.isErr()) {
+        return buildErrorMsg(ctx, msg, rAuth.Err());
+      }
+      const sMsg = await fn({
+        ...msg,
+        auth: rAuth.Ok(),
+      });
+      switch (true) {
+        case isAuthTypeFPCloudJWK(sMsg.auth):
+          return sMsg;
+        case isAuthTypeFPCloud(sMsg.auth):
+          return {
+            ...sMsg,
+            auth: {
+              type: "fp-cloud-jwk",
+              params: {
+                jwk: sMsg.auth.params.jwk,
+              },
+            } satisfies FPJWKCloudAuthType as AuthType, // send me to hell ts
+          };
+        default:
+          return buildErrorMsg(ctx, msg, new Error("unexpected auth"));
+      }
+    }
+    return buildErrorMsg(ctx, msg, new Error("missing auth"));
+  }
+
+  async dispatch(ctx: MsgDispatcherCtx, msg: MsgBase): Promise<Response> {
+    try {
+      // console.log("dispatch-1", msg);
+      const found = Array.from(this.items.values()).find((item) => item.match(msg));
+      if (!found) {
+        // console.log("dispatch-2", msg);
+        return this.send(ctx, buildErrorMsg(ctx, msg, new Error(`unexpected message`)));
+      }
+      if (!found.isNotConn) {
+        // console.log("dispatch-3");
+        return this.validateConn(ctx, msg, (msg) => found.fn(ctx, msg));
+      }
+      // console.log("dispatch-4", msg);
+      return this.send(ctx, await this.validateAuth(ctx, msg, (msg) => found.fn(ctx, msg)));
+    } catch (e) {
+      return this.send(ctx, buildErrorMsg(ctx, msg, e as Error));
+    }
+  }
+}
+++ b/cloud-backend/msg-dispatcher-impl.ts
+import { SuperThis, ps } from "@fireproof/core";
+import { MsgDispatcher } from "./msg-dispatch.js";
+// import { WSRoom } from "./ws-room.js";
+
+const {
+  MsgIsReqGetData,
+  buildResGetData,
+  MsgIsReqPutData,
+  MsgIsReqDelData,
+  buildResDelData,
+  buildResPutData,
+  MsgIsReqDelWAL,
+  MsgIsReqGetWAL,
+  MsgIsReqPutWAL,
+  buildResDelWAL,
+  buildResGetWAL,
+  buildResPutWAL,
+  MsgIsReqGestalt,
+  buildResGestalt,
+  MsgIsReqOpen,
+  buildErrorMsg,
+  buildResOpen,
+  buildResChat,
+  MsgIsReqChat,
+  qsidEqual,
+  MsgIsReqClose,
+  buildResClose,
+  MsgIsBindGetMeta,
+  MsgIsReqDelMeta,
+  MsgIsReqPutMeta,
+} = ps.cloud;
+
+type ReqGetData = ps.cloud.ReqGetData;
+type ReqPutData = ps.cloud.ReqPutData;
+type ReqDelData = ps.cloud.ReqDelData;
+type ReqDelWAL = ps.cloud.ReqDelWAL;
+type ReqGetWAL = ps.cloud.ReqGetWAL;
+type ReqPutWAL = ps.cloud.ReqPutWAL;
+type ReqGestalt = ps.cloud.ReqGestalt;
+type ReqChat = ps.cloud.ReqChat;
+type ReqClose = ps.cloud.ReqClose;
+type MsgWithConnAuth<T extends ps.cloud.MsgBase> = ps.cloud.MsgWithConnAuth<T>;
+type BindGetMeta = ps.cloud.BindGetMeta;
+type ReqDelMeta = ps.cloud.ReqDelMeta;
+type ReqPutMeta = ps.cloud.ReqPutMeta;
+
+export function buildMsgDispatcher(_sthis: SuperThis /*, gestalt: Gestalt, ende: EnDeCoder, wsRoom: WSRoom*/): MsgDispatcher {
+  const dp = MsgDispatcher.new(_sthis /*, gestalt, ende, wsRoom*/);
+  dp.registerMsg(
+    {
+      match: MsgIsReqGestalt,
+      isNotConn: true,
+      fn: (ctx, msg: ReqGestalt) => {
+        const resGestalt = buildResGestalt(msg, ctx.gestalt, msg.auth);
+        // console.log(">>>>>>>>>>>>>>", resGestalt);
+        return resGestalt;
+      },
+    },
+    {
+      match: MsgIsReqOpen,
+      isNotConn: true,
+      fn: (ctx, msg) => {
+        if (!MsgIsReqOpen(msg)) {
+          return buildErrorMsg(ctx, msg, new Error("missing connection"));
+        }
+        if (ctx.wsRoom.isConnected(msg)) {
+          return buildResOpen(ctx.sthis, msg, msg.conn.resId);
+        }
+        // const resId = sthis.nextId(12).str;
+        const resId = ctx.ws.id;
+        const resOpen = buildResOpen(ctx.sthis, msg, resId);
+        ctx.wsRoom.addConn(ctx.ws, resOpen.conn);
+        return resOpen;
+      },
+    },
+    {
+      match: MsgIsReqClose,
+      fn: (ctx, msg: MsgWithConnAuth<ReqClose>) => {
+        ctx.wsRoom.removeConn(msg.conn);
+        return buildResClose(msg, msg.conn);
+      },
+    },
+    {
+      match: MsgIsReqChat,
+      fn: (ctx, msg: MsgWithConnAuth<ReqChat>) => {
+        const conns = ctx.wsRoom.getConns(msg.conn);
+        const ci = conns.map((c) => c.conn);
+        for (const conn of conns) {
+          if (qsidEqual(conn.conn, msg.conn)) {
+            continue;
+          }
+          dp.send(
+            {
+              ...ctx,
+              ws: conn.ws,
+            },
+            buildResChat(msg, conn.conn, `[${msg.conn.reqId}]: ${msg.message}`, ci),
+          );
+        }
+        return buildResChat(msg, msg.conn, `ack: ${msg.message}`, ci);
+      },
+    },
+    {
+      match: MsgIsReqGetData,
+      fn: (ctx, msg: MsgWithConnAuth<ReqGetData>) => {
+        return buildResGetData(ctx, msg, ctx.impl);
+      },
+    },
+    {
+      match: MsgIsReqPutData,
+      fn: (ctx, msg: MsgWithConnAuth<ReqPutData>) => {
+        return buildResPutData(ctx, msg, ctx.impl);
+      },
+    },
+    {
+      match: MsgIsReqDelData,
+      fn: (ctx, msg: MsgWithConnAuth<ReqDelData>) => {
+        return buildResDelData(ctx, msg, ctx.impl);
+      },
+    },
+    {
+      match: MsgIsReqGetWAL,
+      fn: (ctx, msg: MsgWithConnAuth<ReqGetWAL>) => {
+        return buildResGetWAL(ctx, msg, ctx.impl);
+      },
+    },
+    {
+      match: MsgIsReqPutWAL,
+      fn: (ctx, msg: MsgWithConnAuth<ReqPutWAL>) => {
+        return buildResPutWAL(ctx, msg, ctx.impl);
+      },
+    },
+    {
+      match: MsgIsReqDelWAL,
+      fn: (ctx, msg: MsgWithConnAuth<ReqDelWAL>) => {
+        return buildResDelWAL(ctx, msg, ctx.impl);
+      },
+    },
+    {
+      match: MsgIsBindGetMeta,
+      fn: (ctx, msg: MsgWithConnAuth<BindGetMeta>) => {
+        // console.log("MsgIsBindGetMeta", msg);
+        return ctx.impl.handleBindGetMeta(ctx, msg);
+      },
+    },
+    {
+      match: MsgIsReqPutMeta,
+      fn: (ctx, msg: MsgWithConnAuth<ReqPutMeta>) => {
+        return ctx.impl.handleReqPutMeta(ctx, msg);
+      },
+    },
+    {
+      match: MsgIsReqDelMeta,
+      fn: (ctx, msg: MsgWithConnAuth<ReqDelMeta>) => {
+        return ctx.impl.handleReqDelMeta(ctx, msg);
+      },
+    },
+  );
+  return dp;
+}
+++ b/cloud-backend/node-hono-server.ts
+import { UpgradeWebSocket, WSContext, WSEvents, WSMessageReceive } from "hono/ws";
+import {
+  ConnMiddleware,
+  ExposeCtxItem,
+  ExposeCtxItemWithImpl,
+  HonoServerBase,
+  HonoServerFactory,
+  HonoServerImpl,
+  WSContextWithId,
+  WSEventsConnId,
+} from "./hono-server.js";
+import { ResolveOnce, URI } from "@adviser/cement";
+import { Context, Hono } from "hono";
+import { ensureLogger, SuperThis, ps, rt } from "@fireproof/core";
+import { SQLDatabase } from "./meta-merger/abstract-sql.js";
+import { WSRoom } from "./ws-room.js";
+import { ConnItem } from "./msg-dispatch.js";
+import { cloudBackendParams } from "./test-helper.js";
+import { MetaMerger } from "./meta-merger/meta-merger.js";
+
+const { defaultGestalt, isProtocolCapabilities, MsgIsWithConn, qsidKey, jsonEnDe, defaultMsgParams } = ps.cloud;
+type Gestalt = ps.cloud.Gestalt;
+type MsgBase = ps.cloud.MsgBase;
+type MsgerParams = ps.cloud.MsgerParams;
+type MsgWithConnAuth<T extends MsgBase> = ps.cloud.MsgWithConnAuth<T>;
+type QSId = ps.cloud.QSId;
+
+interface ServerType {
+  close(fn: () => void): void;
+}
+
+type serveFn = (options: unknown, listeningListener?: ((info: unknown) => void) | undefined) => ServerType;
+
+export interface NodeHonoFactoryParams {
+  readonly msgP?: MsgerParams;
+  readonly gs?: Gestalt;
+  readonly sql: SQLDatabase;
+}
+
+// const wsConnections = new Map<string, WSContextWithId<WSContext>>();
+class NodeWSRoom implements WSRoom {
+  readonly sthis: SuperThis;
+  readonly id: string;
+
+  readonly _conns = new Map<string, ConnItem>();
+  constructor(sthis: SuperThis) {
+    this.sthis = sthis;
+    this.id = sthis.nextId(12).str;
+  }
+
+  getConns(): ConnItem[] {
+    return Array.from(this._conns.values());
+  }
+  removeConn(conn: QSId): void {
+    // console.log("removeConn", this.id, qsidKey(conn));
+    this._conns.delete(qsidKey(conn));
+  }
+  addConn(ws: WSContextWithId<unknown>, conn: QSId): QSId {
+    // console.log("addConn", this.id, qsidKey(conn));
+    const key = qsidKey(conn);
+    let ci = this._conns.get(key);
+    if (!ci) {
+      ci = { ws, conn, touched: new Date() };
+      this._conns.set(key, ci);
+    }
+    return ci.conn;
+  }
+
+  isConnected(msg: MsgBase): msg is MsgWithConnAuth<MsgBase> {
+    if (!MsgIsWithConn(msg)) {
+      return false;
+    }
+    return this._conns.has(qsidKey(msg.conn));
+  }
+
+  // addConn(ws: WSContextWithId): void {
+  //   wsConnections.add(ws);
+  // }
+
+  // delConn(ws: WSContextWithId): void {
+  //   wsConnections.delete(ws);
+  // }
+
+  // #ensureWSContextWithId(id: string, ws: WSContext) {
+  //   let wsId = wsConnections.get(id);
+  //   if (wsId) {
+  //     return wsId;
+  //   }
+  //   wsId = new WSContextWithId(this.sthis.nextId(12).str, ws);
+  //   wsConnections.set(id, wsId);
+  //   return wsId;
+  // }
+
+  createEvents(outer: WSEventsConnId<unknown>): (c: Context) => WSEvents<unknown> {
+    const id = this.sthis.nextId(12).str;
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars
+    return (_c: Context) => ({
+      onOpen: (evt: Event, ws: WSContext) => {
+        // console.log("onOpen", id);
+        outer.onOpen(evt, new WSContextWithId(id, ws));
+      },
+      onMessage: (evt: MessageEvent<WSMessageReceive>, ws: WSContext) => {
+        outer.onMessage(evt, new WSContextWithId(id, ws));
+      },
+      onClose: (evt: CloseEvent, ws: WSContext) => {
+        // console.log("onClose", id);
+        outer.onClose(evt, new WSContextWithId(id, ws));
+        // wsConnections.delete(id);
+      },
+      onError: (evt: Event, ws: WSContext) => {
+        outer.onError(evt, new WSContextWithId(id, ws));
+      },
+    });
+  }
+
+  // eslint-disable-next-line @typescript-eslint/no-unused-vars
+  acceptConnection(ws: WebSocket, wse: WSEvents): Promise<void> {
+    // const id = this.sthis.nextId(12).str;
+    // wsConnections.set(id, ws);
+    // this.
+
+    throw new Error("Method not implemented.");
+    // const wsCtx = new WSContextWithId(this.sthis.nextId(12).str, ws as WSContextInit);
+
+    // console.log("acceptConnection", wsCtx);
+    // ws.onopen = function(this, ev) {
+    //   console.log("onopen", ev);
+    //   wsConnections.set(wsCtx.id, wsCtx);
+    //   wse.onOpen?.(ev, wsCtx);
+    // }
+    // ws.onerror = (err) => {
+    //   console.log("onerror", err);
+    //   wse.onError?.(err, wsCtx);
+    // };
+    // ws.onclose = function(this, ev) {
+    //   console.log("onclose", ev);
+    //   wse.onClose?.(ev, wsCtx);
+    //   wsConnections.delete(wsCtx.id);
+    // };
+    // ws.onmessage = (evt) => {
+    //   console.log("onmessage", evt);
+    //   // wsCtx.send("Hellox from server");
+    //   wse.onMessage?.(evt, wsCtx);
+    // };
+
+    // ws.accept();
+    // return Promise.resolve();
+  }
+}
+
+const createDB = new ResolveOnce();
+
+export class NodeHonoFactory implements HonoServerFactory {
+  _upgradeWebSocket!: UpgradeWebSocket;
+  _injectWebSocket!: (t: unknown) => void;
+  _serve!: serveFn;
+  _server!: ServerType;
+
+  readonly _wsRoom: NodeWSRoom;
+  // _env!: Env;
+
+  readonly sthis: SuperThis;
+  readonly params: NodeHonoFactoryParams;
+  constructor(sthis: SuperThis, params: NodeHonoFactoryParams) {
+    this.sthis = sthis;
+    this.params = params;
+    this._wsRoom = new NodeWSRoom(sthis);
+  }
+
+  async inject(
+    c: Context,
+    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
+    fn: (rt: ExposeCtxItemWithImpl<NodeWSRoom>) => Promise<Response | void>,
+    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
+  ): Promise<Response | void> {
+    // this._env = c.env;
+    // const sthis = ensureSuperThis();
+    const sthis = this.sthis;
+    const logger = ensureLogger(sthis, `NodeHono[${URI.from(c.req.url).pathname}]`);
+    const ende = jsonEnDe(sthis);
+
+    const id = sthis.nextId(12).str;
+
+    const protocolCapabilities = URI.from(c.req.url)
+      .getParam("capabilities", "reqRes,stream")
+      .split(",")
+      .filter((s) => isProtocolCapabilities(s));
+    const msgP =
+      this.params.msgP ??
+      defaultMsgParams(sthis, {
+        hasPersistent: true,
+        protocolCapabilities,
+      });
+    const gestalt =
+      this.params.gs ??
+      defaultGestalt(msgP, {
+        id: "FP-Storage-Backend", // fpProtocol ? (fpProtocol === "http" ? "HTTP-server" : "WS-server") : "FP-CF-Server",
+      });
+
+    const stsService = await rt.sts.SessionTokenService.createFromEnv();
+    const ctx: ExposeCtxItem<NodeWSRoom> = {
+      id,
+      sthis,
+      logger,
+      wsRoom: this._wsRoom,
+      port: cloudBackendParams(sthis).port,
+      stsService,
+      gestalt,
+      ende,
+      dbFactory: () => this.params.sql,
+    };
+
+    const nhs = new NodeHonoServer(id, this);
+    // return nhs.start(ctx).then((nhs) => fn({ ...ctx, impl: nhs }));
+    return fn({ ...ctx, impl: nhs });
+  }
+
+  async start(app: Hono): Promise<void> {
+    try {
+      await createDB.once(() => {
+        return new MetaMerger("test", this.sthis.logger, this.params.sql).createSchema();
+      });
+
+      const { createNodeWebSocket } = await import("@hono/node-ws");
+      const { serve } = await import("@hono/node-server");
+      this._serve = serve as serveFn;
+      const { upgradeWebSocket, injectWebSocket } = createNodeWebSocket({ app });
+      this._upgradeWebSocket = upgradeWebSocket;
+      this._injectWebSocket = injectWebSocket as (t: unknown) => void;
+    } catch (e) {
+      throw this.sthis.logger.Error().Err(e).Msg("Failed to start NodeHonoFactory").AsError();
+    }
+  }
+
+  async serve(app: Hono, port: number): Promise<void> {
+    await new Promise<void>((resolve) => {
+      this._server = this._serve({ fetch: app.fetch, port }, () => {
+        this._injectWebSocket(this._server);
+        resolve();
+      });
+    });
+  }
+  async close(): Promise<void> {
+    this._server.close(() => {
+      /* */
+    });
+    // return new Promise((res) => this._server.close(() => res()));
+  }
+}
+
+export class NodeHonoServer extends HonoServerBase implements HonoServerImpl {
+  readonly _upgradeWebSocket: UpgradeWebSocket;
+  // readonly wsRoom: NodeWSRoom;
+  readonly wsRoom: WSRoom;
+  constructor(
+    id: string,
+    // sthis: SuperThis,
+    factory: NodeHonoFactory,
+    // gs: Gestalt,
+    // sqldb: SQLDatabase,
+    // wsRoom: WSRoom,
+    // headers?: HttpHeader
+  ) {
+    super(id);
+    this.wsRoom = factory._wsRoom;
+    this._upgradeWebSocket = factory._upgradeWebSocket;
+  }
+
+  // upgradeWebSocket<WebSocket>(createEvents: (c: Context) => WSEventsConnId<WebSocket> | Promise<WSEventsConnId<WebSocket>>): ConnMiddleware {
+  upgradeWebSocket(createEvents: (c: Context) => WSEventsConnId<unknown> | Promise<WSEventsConnId<unknown>>): ConnMiddleware {
+    return async (_conn, c, next) => {
+      const wse = await createEvents(c);
+      return this._upgradeWebSocket((this.wsRoom as NodeWSRoom).createEvents(wse))(c, next);
+    };
+  }
+
+  // override getConnected(): Connected[] {
+  //   // console.log("getConnected", wsConnections.size);
+  //   return Array.from(wsConnections.values()).map(m => ({
+  //     connId: m.id,
+  //     ws: m,
+  //   }))
+  // }
+}
+++ b/cloud-backend/node-serve.ts
+import { Hono } from "hono";
+import { HonoServer } from "./hono-server.js";
+import { NodeHonoFactory } from "./node-hono-server.js";
+import { serve } from "@hono/node-server";
+import { ensureSuperThis } from "use-fireproof";
+import { BetterSQLDatabase } from "./meta-merger/bettersql-abstract-sql.js";
+import { defaultMsgParams } from "../src/protocols/cloud/msger.js";
+import { defaultGestalt } from "../src/protocols/cloud/msg-types.js";
+
+// async function main() {
+//   Deno.serve({
+//     port: 7370,
+//     handler: createHandler(getClient(), Deno.env.toObject()),
+//   });
+// }
+
+// main().catch((err) => {
+//   console.error(err);
+//   Deno.exit(1);
+// });
+
+async function main() {
+  const app = new Hono();
+  const sthis = ensureSuperThis();
+  const msgP = defaultMsgParams(sthis, {
+    hasPersistent: true,
+  });
+  const gestalt = defaultGestalt(msgP, {
+    id: "FP-Storage-Backend", // fpProtocol ? (fpProtocol === "http" ? "HTTP-server" : "WS-server") : "FP-CF-Server",
+  });
+
+  const honoServer = new HonoServer(
+    new NodeHonoFactory(sthis, {
+      msgP,
+      gs: gestalt,
+      sql: new BetterSQLDatabase("./dist/node-meta.sqlite"),
+    }),
+  ).register(app);
+
+  await honoServer.start();
+  // eslint-disable-next-line no-console
+  console.log("Listen on 8909");
+  serve({
+    fetch: app.fetch,
+    port: 8909,
+  });
+}
+
+main().catch((err) => {
+  // eslint-disable-next-line no-console
+  console.error(err);
+  process.exit(1);
+});
+
+// export default {
+//   fetch: async (req, env, ctx): Promise<Response> => {
+//     // console.log("fetch-1", req.url);
+//     await honoServer.start();
+//     // await honoServer.register(app);
+//     // console.log("fetch-2", req.url);
+//     return app.fetch(req, env, ctx);
+//   },
+// } satisfies ExportedHandler<Env>;
+++ b/cloud-backend/pre-signed-url.ts
+import { Result, URI } from "@adviser/cement";
+import { AwsClient } from "aws4fetch";
+import { ps } from "@fireproof/core";
+
+type SignedUrlParam = ps.cloud.SignedUrlParam;
+type MethodSignedUrlParam = ps.cloud.MethodSignedUrlParam;
+type MsgWithTenantLedger<T extends ps.cloud.MsgWithConnAuth> = ps.cloud.MsgWithTenantLedger<T>;
+type MsgWithConnAuth = ps.cloud.MsgWithConnAuth;
+
+export interface PreSignedMsg extends MsgWithTenantLedger<MsgWithConnAuth> {
+  readonly methodParams: MethodSignedUrlParam;
+  readonly params: SignedUrlParam;
+}
+
+// export interface PreSignedConnMsg {
+//   readonly params: SignedUrlParam;
+//   readonly tid: string;
+//   readonly conn: QSId;
+// }
+
+export interface PreSignedEnv {
+  readonly storageUrl: URI;
+  readonly aws: {
+    readonly accessKeyId: string;
+    readonly secretAccessKey: string;
+    readonly region?: string;
+  };
+  readonly test?: {
+    readonly amzDate?: string;
+  };
+}
+
+export async function calculatePreSignedUrl(psm: PreSignedMsg, env: PreSignedEnv): Promise<Result<URI>> {
+  // if (!ipsm.conn) {
+  //   return Result.Err(new Error("Connection is not supported"));
+  // }
+  // const psm = ipsm as PreSignedConnMsg;
+
+  // verify if you are not overriding
+  let store: string = psm.methodParams.store;
+  if (psm.params.index?.length) {
+    store = `${store}-${psm.params.index}`;
+  }
+  const expiresInSeconds = psm.params.expires || 60 * 60;
+
+  const suffix = "";
+  // switch (psm.params.store) {
+  //   case "wal":
+  //   case "meta":
+  //     suffix = ".json";
+  //     break;
+  //   default:
+  //     break;
+  // }
+
+  const opUrl = env.storageUrl
+    .build()
+    // .protocol(vals.protocuol === "ws" ? "http:" : "https:")
+    .setParam("X-Amz-Expires", expiresInSeconds.toString())
+    .setParam("tid", psm.tid)
+    .appendRelative(psm.tenant.tenant)
+    .appendRelative(psm.tenant.ledger)
+    .appendRelative(store)
+    .appendRelative(`${psm.params.key}${suffix}`)
+    .URI();
+  const a4f = new AwsClient({
+    ...env.aws,
+    region: env.aws.region || "us-east-1",
+    service: "s3",
+  });
+  const signedUrl = await a4f
+    .sign(
+      new Request(opUrl.toString(), {
+        method: psm.methodParams.method,
+      }),
+      {
+        aws: {
+          signQuery: true,
+          datetime: env.test?.amzDate,
+          // datetime: env.TEST_DATE,
+        },
+      },
+    )
+    .then((res) => res.url);
+  // console.log("opUrl", opUrl.toString(), psm.methodParams.method, signedUrl, env.aws);
+  return Result.Ok(URI.from(signedUrl));
+}
+++ b/cloud-backend/test-helper.ts
+import { BuildURI, CoerceURI, Result, URI } from "@adviser/cement";
+import { SuperThis, rt, ps, ensureSuperThis } from "@fireproof/core";
+import type { GenerateKeyPairOptions } from "jose/key/generate/keypair";
+import { HonoServer } from "./hono-server.js";
+import { BetterSQLDatabase } from "./meta-merger/bettersql-abstract-sql.js";
+import { NodeHonoFactory } from "./node-hono-server.js";
+import { Hono } from "hono";
+
+type MsgerParamsWithEnDe = ps.cloud.MsgerParamsWithEnDe;
+type MsgRawConnection<T extends MsgBase> = ps.cloud.MsgRawConnection<T>;
+type MsgBase = ps.cloud.MsgBase;
+type Gestalt = ps.cloud.Gestalt;
+type MsgerParams = ps.cloud.MsgerParams;
+
+const {
+  defaultGestalt,
+  defaultMsgParams,
+  WSConnection,
+  HttpConnection,
+  Msger,
+  authTypeFromUri,
+  buildReqGestalt,
+  MsgIsResGestalt,
+  applyStart,
+  MsgIsError,
+} = ps.cloud;
+
+export function httpStyle(
+  sthis: SuperThis,
+  applyAuthToURI: (uri: CoerceURI) => URI,
+  port: number,
+  msgP: MsgerParamsWithEnDe,
+  my: Gestalt,
+) {
+  const remote = defaultGestalt(defaultMsgParams(sthis, { hasPersistent: true, protocolCapabilities: ["reqRes"] }), {
+    id: "HTTP-server",
+  });
+  const exGt = { my, remote };
+  return {
+    name: "HTTP",
+    remoteGestalt: remote,
+    cInstance: HttpConnection,
+    ok: {
+      url: () =>
+        BuildURI.from(`http://127.0.0.1:${port}`)
+          // .pathname(path)
+          .setParam("capabilities", remote.protocolCapabilities.join(","))
+          .URI(),
+      open: () =>
+        applyStart(
+          Msger.openHttp(
+            sthis,
+            [BuildURI.from(`http://127.0.0.1:${port}/fp`).setParam("capabilities", remote.protocolCapabilities.join(",")).URI()],
+            {
+              ...msgP,
+              // protocol: "http",
+              timeout: 1000,
+            },
+            exGt,
+          ),
+        ),
+    },
+    connRefused: {
+      url: () => URI.from(`http://127.0.0.1:${port - 1}/`),
+      open: async (): Promise<Result<MsgRawConnection<MsgBase>>> => {
+        const ret = await Msger.openHttp(
+          sthis,
+          [URI.from(`http://localhost:${port - 1}/`)],
+          {
+            ...msgP,
+            // protocol: "http",
+            timeout: 1000,
+          },
+          exGt,
+        );
+        if (ret.isErr()) {
+          return ret;
+        }
+
+        const rAuth = await authTypeFromUri(sthis.logger, applyAuthToURI(`http://localhost:${port - 1}/`));
+        // should fail
+        const res = await ret.Ok().request(buildReqGestalt(sthis, rAuth.Ok(), my), { waitFor: MsgIsResGestalt });
+        if (MsgIsError(res)) {
+          return Result.Err(res.message);
+        }
+        return ret;
+      },
+    },
+    timeout: {
+      url: () => URI.from(`http://4.7.1.1:${port}/`),
+      open: async (): Promise<Result<MsgRawConnection<MsgBase>>> => {
+        const ret = await Msger.openHttp(
+          sthis,
+          [URI.from(`http://4.7.1.1:${port}/`)],
+          {
+            ...msgP,
+            // protocol: "http",
+            timeout: 500,
+          },
+          exGt,
+        );
+        // should fail
+        const rAuth = await authTypeFromUri(sthis.logger, applyAuthToURI(`http://4.7.1.1:${port}/`));
+        const res = await ret.Ok().request(buildReqGestalt(sthis, rAuth.Ok(), my), { waitFor: MsgIsResGestalt });
+        if (MsgIsError(res)) {
+          return Result.Err(res.message);
+        }
+        return ret;
+      },
+    },
+  };
+}
+
+export function wsStyle(
+  sthis: SuperThis,
+  applyAuthToURI: (uri: CoerceURI) => URI,
+  port: number,
+  msgP: MsgerParamsWithEnDe,
+  my: Gestalt,
+) {
+  const remote = defaultGestalt(defaultMsgParams(sthis, { hasPersistent: true, protocolCapabilities: ["stream"] }), {
+    id: "WS-server",
+  });
+  const exGt = { my, remote };
+  return {
+    name: "WS",
+    remoteGestalt: remote,
+    cInstance: WSConnection,
+    ok: {
+      url: () =>
+        BuildURI.from(`http://127.0.0.1:${port}`)
+          // .pathname(path)
+          .setParam("capabilities", remote.protocolCapabilities.join(","))
+          .URI(),
+      open: () =>
+        applyStart(
+          Msger.openWS(
+            sthis,
+            applyAuthToURI(
+              BuildURI.from(`http://127.0.0.1:${port}/ws`).setParam("capabilities", remote.protocolCapabilities.join(",")).URI(),
+            ),
+            {
+              ...msgP,
+              // protocol: "ws",
+              timeout: 1000,
+            },
+            exGt,
+          ),
+        ),
+    },
+    connRefused: {
+      url: () => URI.from(`http://127.0.0.1:${port - 1}/`),
+      open: () =>
+        Msger.openWS(
+          sthis,
+          applyAuthToURI(URI.from(`http://localhost:${port - 1}/`)),
+          {
+            ...msgP,
+            // protocol: "ws",
+            timeout: 1000,
+          },
+          exGt,
+        ),
+    },
+    timeout: {
+      url: () => URI.from(`http://4.7.1.1:${port - 1}/`),
+      open: () =>
+        Msger.openWS(
+          sthis,
+          applyAuthToURI(URI.from(`http://4.7.1.1:${port - 1}/`)),
+          {
+            ...msgP,
+            // protocol: "ws",
+            timeout: 500,
+          },
+          exGt,
+        ),
+    },
+  };
+}
+
+export function NodeHonoServerFactory(sthis: SuperThis) {
+  return {
+    name: "NodeHonoServer",
+    port: cloudBackendParams(sthis).port,
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars
+    factory: async (sthis: SuperThis, msgP: MsgerParams, remoteGestalt: Gestalt, _port: number, pubEnvJWK: string) => {
+      // const { env } = await resolveToml();
+      // sthis.env.set(envKeyDefaults.PUBLIC, pubEnvJWK);
+      // sthis.env.sets(env as unknown as Record<string, string>);
+      const nhf = new NodeHonoFactory(sthis, {
+        msgP,
+        gs: remoteGestalt,
+        sql: new BetterSQLDatabase("./dist/node-meta.sqlite"),
+      });
+      return new HonoServer(nhf);
+    },
+  };
+}
+
+export function portRandom(): number {
+  return process.env.FP_WRANGLER_PORT ? +process.env.FP_WRANGLER_PORT : 1024 + Math.floor(Math.random() * (65536 - 1024));
+}
+
+export interface BackendParams {
+  readonly port: number;
+  readonly pid: number;
+  readonly envName: string;
+}
+
+export function cloudBackendParams(sthis: SuperThis): BackendParams {
+  const cf_backend = sthis.env.get("FP_TEST_CLOUD_BACKEND");
+  if (!cf_backend) {
+    return {
+      port: 0,
+      pid: 0,
+      envName: "not-set",
+    };
+  }
+  return JSON.parse(cf_backend) as BackendParams;
+}
+
+export interface MockJWK {
+  keys: rt.sts.KeysResult;
+  authType: ps.cloud.FPJWKCloudAuthType;
+  applyAuthToURI: (uri: CoerceURI) => URI;
+}
+
+export async function mockJWK(claim: Partial<ps.cloud.TokenForParam> = {}, sthis = ensureSuperThis()): Promise<MockJWK> {
+  // that could be solved better now with globalSetup.v2-cloud.ts
+  const publicJWK = await rt.sts.env2jwk(
+    "zeWndr5LEoaySgKSo2aZniYqaZvsKKu1RhfpL2R3hjarNgfXfN7CvR1cAiT74TMB9MQtMvh4acC759Xf8rTwCgxXvGHCBjHngThNtYpK2CoysiAMRJFUi9irMY9H7WApJkfxB15n8ss8iaEojcGB7voQVyk2T6aFPRnNdkoB6v5zk",
+    "ES256",
+    sthis,
+  );
+  const privateJWK = await rt.sts.env2jwk(
+    "z33KxHvFS3jLz72v9DeyGBqo79qkbpv5KNP43VKUKSh1fcLb629pFTFyiJEosZ9jCrr8r9TE44KXCPZ2z1FeWGsV1N5gKjGWmZvubUwNHPynxNjCYy4GeYoQ8ukBiKjcPG22pniWCnRMwZvueUBkVk6NdtNY1uwyPk2HAGTsfrw5CBJvTcYsaFeG11SKZ9Q55Xk1W2p4gtZQHzkYHdfQQhgZ73Ttq7zmFoms73kh7MsudYzErx",
+    "ES256",
+    sthis,
+  );
+
+  const keys = await rt.sts.SessionTokenService.generateKeyPair(
+    "ES256",
+    {
+      extractable: true,
+    },
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars
+    (_alg: string, _options: GenerateKeyPairOptions) => {
+      return Promise.resolve({
+        privateKey: privateJWK,
+        publicKey: publicJWK,
+      });
+    },
+  );
+
+  const sts = await rt.sts.SessionTokenService.create({
+    token: keys.strings.privateKey,
+  });
+  const jwk = await sts.tokenFor({
+    userId: "hello",
+    tenants: [],
+    ledgers: [],
+    ...claim,
+  });
+
+  return {
+    keys,
+    authType: {
+      type: "fp-cloud-jwk",
+      params: {
+        jwk,
+      },
+    },
+    applyAuthToURI: (uri: CoerceURI) => BuildURI.from(uri).setParam("authJWK", jwk).URI(),
+  };
+}
+
+export async function setupBackend(
+  sthis: SuperThis,
+  // backend: "D1" | "DO",
+  // key: string,
+  port = portRandom(),
+): Promise<{ port: number; pid: number; envName: string; hs: HonoServer }> {
+  const envName = `test`;
+  if (process.env.FP_WRANGLER_PORT) {
+    return Promise.resolve({ port: +process.env.FP_WRANGLER_PORT, pid: 0, envName, hs: {} as HonoServer });
+  }
+
+  const nhf = new NodeHonoFactory(sthis, {
+    // msgP,
+    // gs: remoteGestalt,
+    sql: new BetterSQLDatabase("./dist/node-meta.sqlite"),
+  });
+  const app = new Hono();
+  const hs = new HonoServer(nhf);
+  await hs.start().then((srv) => srv.once(app, port));
+  //   $.verbose = !!process.env.FP_DEBUG;
+  //   const auth = await mockJWK({}, sthis);
+  //   await writeEnvFile(sthis, tomlFile, envName, auth.keys.strings.publicKey);
+  //   // .dev.vars.<environment-name>
+  //   const runningWrangler = $`
+  //               wrangler dev -c ${tomlFile} --port ${port} --env ${envName} --no-show-interactive-dev-session --no-live-reload &
+  //               waitPid=$!
+  //               echo "PID:$waitPid"
+  //               wait $waitPid`;
+  //   const waitReady = new Future();
+  //   let pid: number | undefined;
+  //   runningWrangler.stdout.on("data", (chunk) => {
+  //     // console.log(">>", chunk.toString())
+  //     const mightPid = chunk.toString().match(/PID:(\d+)/)?.[1];
+  //     if (mightPid) {
+  //       pid = +mightPid;
+  //     }
+  //     if (chunk.includes("Starting local serv")) {
+  //       waitReady.resolve(true);
+  //     }
+  //   });
+  //   runningWrangler.stderr.on("data", (chunk) => {
+  //     // eslint-disable-next-line no-console
+  //     console.error("!!", chunk.toString());
+  //   });
+  //   await waitReady.asPromise();
+  return { port, pid: 0, envName, hs };
+}
+++ b/cloud-backend/ws-room.ts
+import { ps } from "@fireproof/core";
+
+import { WSContextWithId } from "./hono-server.js";
+import { ConnItem } from "./msg-dispatch.js";
+
+type QSId = ps.cloud.QSId;
+type MsgBase = ps.cloud.MsgBase;
+type MsgWithConnAuth<T extends ps.cloud.MsgBase> = ps.cloud.MsgWithConnAuth<T>;
+
+export interface WSRoom {
+  // acceptConnection(ws: WebSocket, wse: WSEvents, ctx: CTX): Promise<void>;
+
+  getConns(conn: QSId): ConnItem[];
+  removeConn(conn: QSId): void;
+  addConn(ws: WSContextWithId<unknown>, conn: QSId): QSId;
+  isConnected(msg: MsgBase): msg is MsgWithConnAuth<MsgBase>;
+}
+++ b/cloud-backend/ws-sockets.test.ts
+import { ensureSuperThis } from "@fireproof/core";
+
+import { MockJWK, mockJWK, NodeHonoServerFactory } from "./test-helper.js";
+import { Future, Result } from "@adviser/cement";
+import { ps } from "@fireproof/core";
+
+const { MsgIsResChat, Msger, buildReqChat } = ps.cloud;
+
+describe("test multiple connections", () => {
+  const sthis = ensureSuperThis();
+
+  describe.each([
+    // dummy
+    NodeHonoServerFactory(sthis),
+    // CFHonoServerFactory(sthis),
+  ])("$name - Gateway", ({ port }) => {
+    // const msgP = defaultMsgParams(sthis, { hasPersistent: true });
+
+    // const my = defaultGestalt(msgP, { id: "FP-Universal-Client" });
+    // let stype;
+    const connections = 3;
+
+    // let hserv: HonoServer;
+
+    let auth: MockJWK;
+
+    beforeAll(async () => {
+      auth = await mockJWK();
+      //stype = wsStyle(sthis, auth.applyAuthToURI, port, msgP, my);
+
+      // const app = new Hono();
+      // hserv = await factory(sthis, msgP, stype.remoteGestalt, port, auth.keys.strings.publicKey).then((srv) => srv.once(app, port));
+    });
+    afterAll(async () => {
+      // await hserv.close();
+    });
+
+    it("could open multiple connections", async () => {
+      const conns = await Promise.all(
+        Array(connections)
+          .fill(0)
+          .map(() => {
+            return Msger.connect(sthis, auth.authType, `http://localhost:${port}/fp?protocol=ws`);
+          }),
+      ).then((cs) => cs.map((c) => c.Ok().attachAuth(() => Promise.resolve(Result.Ok(auth.authType)))));
+
+      const ready = new Future<void>();
+      let total = (connections * (connections + 1)) / 2;
+      // const recvSet = new Set(conns.map((c) => c.conn.reqId));
+      for (const c of conns) {
+        c.onMsg((m) => {
+          if (MsgIsResChat(m)) {
+            // console.log("Got a chat response", total--, qsidKey(m.conn));
+            total--;
+            if (total === 0) {
+              ready.resolve();
+            }
+            // recvSet.delete(m.conn.reqId);
+            // if (recvSet.size === 0) {
+            // ready.resolve();
+            // }
+          }
+        });
+      }
+
+      const rest = [...conns];
+      for (const c of conns) {
+        // console.log("Sending a chat request", rest.length, conns.length);
+        const act = await c.request(buildReqChat(sthis, auth.authType, c.conn, "Hello"), {
+          waitFor: MsgIsResChat,
+        });
+        if (MsgIsResChat(act)) {
+          expect(act.targets.length).toBe(rest.length);
+        } else {
+          assert.fail("Expected a response");
+        }
+        await c.close((await c.msgConnAuth()).Ok());
+        rest.shift();
+      }
+
+      // await conns[0].send(buildReqGestalt(sthis, my, true));
+      await ready.asPromise();
+    });
+  });
+});
+++ b/globalSetup.cloud.ts
+import { HonoServer } from "./cloud-backend/hono-server.js";
+import { cloudBackendParams, mockJWK, setupBackend } from "./cloud-backend/test-helper.js";
+import { ensureSuperThis } from "./src/utils.js";
+
+const sthis = ensureSuperThis();
+let hs: HonoServer;
+export async function setup() {
+  const keys = await mockJWK({}, sthis);
+
+  process.env["CLOUD_SESSION_TOKEN_PUBLIC"] = keys.keys.strings.publicKey;
+  process.env["STORAGE_URL"] = "http://localhost:9000/testbucket";
+  process.env["ACCESS_KEY_ID"] = "minioadmin";
+  process.env["SECRET_ACCESS_KEY"] = "minioadmin";
+
+  const params = await setupBackend(sthis);
+  hs = params.hs;
+  process.env[`FP_TEST_CLOUD_BACKEND`] = JSON.stringify({
+    port: params.port,
+    pid: params.pid,
+    envName: params.envName,
+  });
+
+  process.env.FP_STORAGE_URL = keys
+    .applyAuthToURI(`fpcloud://localhost:${params.port}/?tenant=${sthis.nextId().str}&ledger=test-l&protocol=ws`)
+    .toString();
+
+  // eslint-disable-next-line no-console
+  console.log("Started node-backend process - ", cloudBackendParams(sthis).pid, "on port", params.port);
+}
+
+export async function teardown() {
+  // eslint-disable-next-line no-console
+  console.log("Stopping node-backend process - ", cloudBackendParams(sthis).pid);
+  hs.close();
+  // process.kill(cloudBackendParams(sthis).pid);
+}
+++ b/package-fireproof-core.json
+    "@adviser/cement": "~0.4.2!",
+    "jose": "from-package-json",
+    "p-retry": "from-package-json",
+    "ws": "from-package-json"
+++ b/package.json
+    "@hono/node-server": "^1.13.8",
+    "@hono/node-ws": "^1.1.0",
+    "@types/better-sqlite3": "^7.6.12",
+    "@types/ws": "^8.18.0",
+    "aws4fetch": "^1.0.20",
+    "better-sqlite3": "^11.8.1",
+    "hono": "^4.7.4",
+    "jose": "^6.0.10",
+    "prolly-trees": "^1.0.4",
+    "randombytes": "^2.1.0",
+    "react": "^18.3.1",
+    "ws": "^8.18.1"
+      "better-sqlite3",
+      "edgedriver",
+++ b/pnpm-lock.yaml
+      randombytes:
+        specifier: ^2.1.0
+        version: 2.1.0
+      react:
+        specifier: ^18.3.1
+        version: 18.3.1
+      ws:
+        specifier: ^8.18.1
+        version: 8.18.1
+      '@hono/node-server':
+        specifier: ^1.13.8
+        version: 1.13.8(hono@4.7.4)
+      '@hono/node-ws':
+        specifier: ^1.1.0
+        version: 1.1.0(@hono/node-server@1.13.8(hono@4.7.4))(hono@4.7.4)
+      '@types/better-sqlite3':
+        specifier: ^7.6.12
+        version: 7.6.12
+      '@types/ws':
+        specifier: ^8.18.0
+        version: 8.18.0
+      aws4fetch:
+        specifier: ^1.0.20
+        version: 1.0.20
+      better-sqlite3:
+        specifier: ^11.8.1
+        version: 11.8.1
+      hono:
+        specifier: ^4.7.4
+        version: 4.7.4
+      jose:
+        specifier: ^6.0.10
+        version: 6.0.10
+  '@hono/node-server@1.13.8':
+    resolution: {integrity: sha512-fsn8ucecsAXUoVxrUil0m13kOEq4mkX4/4QozCqmY+HpGfKl74OYSn8JcMA8GnG0ClfdRI4/ZSeG7zhFaVg+wg==}
+    engines: {node: '>=18.14.1'}
+    peerDependencies:
+      hono: ^4
+
+  '@hono/node-ws@1.1.0':
+    resolution: {integrity: sha512-uHaz1EPguJqsUmA+Jmhdi/DTRAMs2Fvcy7qno9E48rlK3WBtyGQw4u4DKlc+o18Nh1DGz2oA1n9hCzEyhVBeLw==}
+    engines: {node: '>=18.14.1'}
+    peerDependencies:
+      '@hono/node-server': ^1.11.1
+      hono: ^4.6.0
+
+  '@types/better-sqlite3@7.6.12':
+    resolution: {integrity: sha512-fnQmj8lELIj7BSrZQAdBMHEHX8OZLYIHXqAKT1O7tDfLxaINzf00PMjw22r3N/xXh0w/sGHlO6SVaCQ2mj78lg==}
+
+  aws4fetch@1.0.20:
+    resolution: {integrity: sha512-/djoAN709iY65ETD6LKCtyyEI04XIBP5xVvfmNxsEP0uJB5tyaGBztSryRr4HqMStr9R06PisQE7m9zDTXKu6g==}
+
+  better-sqlite3@11.8.1:
+    resolution: {integrity: sha512-9BxNaBkblMjhJW8sMRZxnxVTRgbRmssZW0Oxc1MPBTfiR+WW21e2Mk4qu8CzrcZb1LwPCnFsfDEzq+SNcBU8eg==}
+
+  bindings@1.5.0:
+    resolution: {integrity: sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==}
+
+  chownr@1.1.4:
+    resolution: {integrity: sha512-jJ0bqzaylmJtVnNgzTeSOs8DPavpbYgEr/b0YL8/2GO3xJEhInFmhKMUnEJQjZumK7KXGFhUy89PrsJWlakBVg==}
+
+  decompress-response@6.0.0:
+    resolution: {integrity: sha512-aW35yZM6Bb/4oJlZncMH2LCoZtJXTRxES17vE3hoRiowU2kWHaJKFkSBDnDR+cm9J+9QhXmREyIfv0pji9ejCQ==}
+    engines: {node: '>=10'}
+
+  deep-extend@0.6.0:
+    resolution: {integrity: sha512-LOHxIOaPYdHlJRtCQfDIVZtfw/ufM8+rVj649RIHzcm/vGwQRXFt6OPqIFWsm2XEMrNIEtWR64sY1LEKD2vAOA==}
+    engines: {node: '>=4.0.0'}
+
+  detect-libc@2.0.3:
+    resolution: {integrity: sha512-bwy0MGW55bG41VqxxypOsdSdGqLwXPI/focwgTYCFMbdUiBAxLg9CFzG08sz2aqzknwiX7Hkl0bQENjg8iLByw==}
+    engines: {node: '>=8'}
+
+  expand-template@2.0.3:
+    resolution: {integrity: sha512-XYfuKMvj4O35f/pOXLObndIRvyQ+/+6AhODh+OKWj9S9498pHHn/IMszH+gt0fBCRWMNfk1ZSp5x3AifmnI2vg==}
+    engines: {node: '>=6'}
+
+  file-uri-to-path@1.0.0:
+    resolution: {integrity: sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw==}
+
+  fs-constants@1.0.0:
+    resolution: {integrity: sha512-y6OAwoSIf7FyjMIv94u+b5rdheZEjzR63GTyZJm5qh4Bi+2YgwLCcI/fPFZkL5PSixOt6ZNKm+w+Hfp/Bciwow==}
+
+  github-from-package@0.0.0:
+    resolution: {integrity: sha512-SyHy3T1v2NUXn29OsWdxmK6RwHD+vkj3v8en8AOBZ1wBQ/hCAQ5bAQTD02kW4W9tUp/3Qh6J8r9EvntiyCmOOw==}
+
+  hono@4.7.4:
+    resolution: {integrity: sha512-Pst8FuGqz3L7tFF+u9Pu70eI0xa5S3LPUmrNd5Jm8nTHze9FxLTK9Kaj5g/k4UcwuJSXTP65SyHOPLrffpcAJg==}
+    engines: {node: '>=16.9.0'}
+
+  ini@1.3.8:
+    resolution: {integrity: sha512-JV/yugV2uzW5iMRSiZAyDtQd+nxtUnjeLt0acNdw98kKLrvuRVyB80tsREOE7yvGVgalhZ6RNXCmEHkUKBKxew==}
+
+  jose@6.0.10:
+    resolution: {integrity: sha512-skIAxZqcMkOrSwjJvplIPYrlXGpxTPnro2/QWTDCxAdWQrSTV5/KqspMWmi5WAx5+ULswASJiZ0a+1B/Lxt9cw==}
+
+  mimic-response@3.1.0:
+    resolution: {integrity: sha512-z0yWI+4FDrrweS8Zmt4Ej5HdJmky15+L2e6Wgn3+iK5fWzb6T3fhNFq2+MeTRb064c6Wr4N/wv0DzQTjNzHNGQ==}
+    engines: {node: '>=10'}
+
+  mkdirp-classic@0.5.3:
+    resolution: {integrity: sha512-gKLcREMhtuZRwRAfqP3RFW+TK4JqApVBtOIftVgjuABpAtpxhPGaDcfvbhNvD0B8iD1oUr/txX35NjcaY6Ns/A==}
+
+  napi-build-utils@2.0.0:
+    resolution: {integrity: sha512-GEbrYkbfF7MoNaoh2iGG84Mnf/WZfB0GdGEsM8wz7Expx/LlWf5U8t9nvJKXSp3qr5IsEbK04cBGhol/KwOsWA==}
+
+  node-abi@3.74.0:
+    resolution: {integrity: sha512-c5XK0MjkGBrQPGYG24GBADZud0NCbznxNx0ZkS+ebUTrmV1qTDxPxSL8zEAPURXSbLRWVexxmP4986BziahL5w==}
+    engines: {node: '>=10'}
+
+  prebuild-install@7.1.3:
+    resolution: {integrity: sha512-8Mf2cbV7x1cXPUILADGI3wuhfqWvtiLA1iclTDbFRZkgRQS0NqsPZphna9V+HyTEadheuPmjaJMsbzKQFOzLug==}
+    engines: {node: '>=10'}
+    hasBin: true
+
+  randombytes@2.1.0:
+    resolution: {integrity: sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==}
+
+  rc@1.2.8:
+    resolution: {integrity: sha512-y3bGgqKj3QBdxLbLkomlohkvsA8gdAiUQlSBJnBhfn+BPxg4bc62d8TcBW15wavDfgexCgccckhcZvywyQYPOw==}
+    hasBin: true
+
+  simple-concat@1.0.1:
+    resolution: {integrity: sha512-cSFtAPtRhljv69IK0hTVZQ+OfE9nePi/rtJmw5UjHeVyVroEqJXP1sFztKUy1qU+xvz3u/sfYJLa947b7nAN2Q==}
+
+  simple-get@4.0.1:
+    resolution: {integrity: sha512-brv7p5WgH0jmQJr1ZDDfKDOSeWWg+OVypG99A/5vYGPqJ6pxiaHLy8nxtFjBA7oMa01ebA9gfh1uMCFqOuXxvA==}
+
+  strip-json-comments@2.0.1:
+    resolution: {integrity: sha512-4gB8na07fecVVkOI6Rs4e7T6NOTki5EmL7TUduTs6bu3EdnSycntVJ4re8kgZA+wx9IueI2Y11bfbgwtzuE0KQ==}
+    engines: {node: '>=0.10.0'}
+
+  tar-fs@2.1.2:
+    resolution: {integrity: sha512-EsaAXwxmx8UB7FRKqeozqEPop69DXcmYwTQwXvyAPF352HJsPdkVhvTaDPYqfNgruveJIJy3TA2l+2zj8LJIJA==}
+
+  tar-stream@2.2.0:
+    resolution: {integrity: sha512-ujeqbceABgwMZxEJnk2HDY2DlnUZ+9oEcb1KzTVfYHio0UE6dG71n60d8D2I4qNvleWrrXpmjpt7vZeF1LnMZQ==}
+    engines: {node: '>=6'}
+
+  tunnel-agent@0.6.0:
+    resolution: {integrity: sha512-McnNiV1l8RYeY8tBgEpuodCC1mLUdbSN+CYBL7kJsJNInOP8UjDDEwdk6Mw60vdLLrr5NHKZhMAOSrR2NZuQ+w==}
+
+  '@hono/node-server@1.13.8(hono@4.7.4)':
+    dependencies:
+      hono: 4.7.4
+
+  '@hono/node-ws@1.1.0(@hono/node-server@1.13.8(hono@4.7.4))(hono@4.7.4)':
+    dependencies:
+      '@hono/node-server': 1.13.8(hono@4.7.4)
+      hono: 4.7.4
+      ws: 8.18.1
+    transitivePeerDependencies:
+      - bufferutil
+      - utf-8-validate
+
+  '@types/better-sqlite3@7.6.12':
+    dependencies:
+      '@types/node': 22.10.5
+
+  aws4fetch@1.0.20: {}
+
+  better-sqlite3@11.8.1:
+    dependencies:
+      bindings: 1.5.0
+      prebuild-install: 7.1.3
+
+  bindings@1.5.0:
+    dependencies:
+      file-uri-to-path: 1.0.0
+
+  chownr@1.1.4: {}
+
+  decompress-response@6.0.0:
+    dependencies:
+      mimic-response: 3.1.0
+
+  deep-extend@0.6.0: {}
+
+  detect-libc@2.0.3: {}
+
+  expand-template@2.0.3: {}
+
+  file-uri-to-path@1.0.0: {}
+
+  fs-constants@1.0.0: {}
+
+  github-from-package@0.0.0: {}
+
+  hono@4.7.4: {}
+
+  ini@1.3.8: {}
+
+  jose@6.0.10: {}
+
+  mimic-response@3.1.0: {}
+
+  mkdirp-classic@0.5.3: {}
+
+  napi-build-utils@2.0.0: {}
+
+  node-abi@3.74.0:
+    dependencies:
+      semver: 7.7.1
+
+  prebuild-install@7.1.3:
+    dependencies:
+      detect-libc: 2.0.3
+      expand-template: 2.0.3
+      github-from-package: 0.0.0
+      minimist: 1.2.8
+      mkdirp-classic: 0.5.3
+      napi-build-utils: 2.0.0
+      node-abi: 3.74.0
+      pump: 3.0.2
+      rc: 1.2.8
+      simple-get: 4.0.1
+      tar-fs: 2.1.2
+      tunnel-agent: 0.6.0
+
+  randombytes@2.1.0:
+    dependencies:
+      safe-buffer: 5.2.1
+
+  rc@1.2.8:
+    dependencies:
+      deep-extend: 0.6.0
+      ini: 1.3.8
+      minimist: 1.2.8
+      strip-json-comments: 2.0.1
+
+  simple-concat@1.0.1: {}
+
+  simple-get@4.0.1:
+    dependencies:
+      decompress-response: 6.0.0
+      once: 1.4.0
+      simple-concat: 1.0.1
+
+  strip-json-comments@2.0.1: {}
+
+  tar-fs@2.1.2:
+    dependencies:
+      chownr: 1.1.4
+      mkdirp-classic: 0.5.3
+      pump: 3.0.2
+      tar-stream: 2.2.0
+
+  tar-stream@2.2.0:
+    dependencies:
+      bl: 4.1.0
+      end-of-stream: 1.4.4
+      fs-constants: 1.0.0
+      inherits: 2.0.4
+      readable-stream: 3.6.2
+
+  tunnel-agent@0.6.0:
+    dependencies:
+      safe-buffer: 5.2.1
+
+  wrappy@1.0.2: {}
+++ b/setup.cloud.js
+// eslint-disable-next-line no-undef
+process.env.FP_KEYBAG_URL = "memory://keybag";
+++ b/src/index.ts
+export * as ps from "./protocols/index.js";
+export * as protocols from "./protocols/index.js";
+
+++ b/src/protocols/cloud/http-connection.ts
+import { HttpHeader, Logger, Result, URI, exception2Result } from "@adviser/cement";
+import { ensureLogger } from "../../utils.js";
+import { MsgBase, buildErrorMsg, MsgWithError, RequestOpts, MsgIsError } from "./msg-types.js";
+import {
+  ActiveStream,
+  ExchangedGestalt,
+  MsgerParamsWithEnDe,
+  MsgRawConnection,
+  OnMsgFn,
+  selectRandom,
+  timeout,
+  UnReg,
+} from "./msger.js";
+import { MsgRawConnectionBase } from "./msg-raw-connection-base.js";
+import { SuperThis } from "../../types.js";
+
+function toHttpProtocol(uri: URI): URI {
+  const protocol = (uri.getParam("protocol") ?? uri.protocol).replace(/:$/, "");
+  const toFix = uri.build();
+  switch (protocol) {
+    case "ws":
+    case "http":
+      toFix.protocol("http");
+      break;
+    case "https":
+    case "wss":
+    default:
+      toFix.protocol("https");
+      break;
+  }
+  return toFix.URI();
+}
+
+export class HttpConnection extends MsgRawConnectionBase implements MsgRawConnection {
+  readonly logger: Logger;
+  readonly msgP: MsgerParamsWithEnDe;
+
+  readonly baseURIs: { in: URI; cleaned: URI }[];
+
+  readonly #onMsg = new Map<string, OnMsgFn>();
+
+  constructor(sthis: SuperThis, uris: URI[], msgP: MsgerParamsWithEnDe, exGestalt: ExchangedGestalt) {
+    super(sthis, exGestalt);
+    this.logger = ensureLogger(sthis, "HttpConnection");
+    // this.msgParam = msgP;
+    this.baseURIs = uris.map((uri) => ({
+      in: uri,
+      cleaned: toHttpProtocol(uri),
+    }));
+    this.msgP = msgP;
+  }
+
+  // eslint-disable-next-line @typescript-eslint/no-unused-vars
+  send<S extends MsgBase, Q extends MsgBase>(_msg: Q): Promise<MsgWithError<S>> {
+    throw new Error("Method not implemented.");
+  }
+
+  async start(): Promise<Result<void>> {
+    // if (this._qsOpen.req) {
+    //   const sOpen = await this.request(this._qsOpen.req, { waitFor: MsgIsResOpen });
+    //   if (!MsgIsResOpen(sOpen)) {
+    //     return Result.Err(this.logger.Error().Any("Err", sOpen).Msg("unexpected response").AsError());
+    //   }
+    //   this._qsOpen.res = sOpen;
+    // }
+    return Result.Ok(undefined);
+  }
+
+  async close(): Promise<Result<void>> {
+    await Promise.all(Array.from(this.activeBinds.values()).map((state) => state.controller?.close()));
+    this.#onMsg.clear();
+    return Result.Ok(undefined);
+  }
+
+  toMsg<S extends MsgBase>(msg: MsgWithError<S>): MsgWithError<S> {
+    this.#onMsg.forEach((fn) => fn(msg));
+    return msg;
+  }
+
+  onMsg(fn: OnMsgFn): UnReg {
+    const key = this.sthis.nextId().str;
+    this.#onMsg.set(key, fn);
+    return () => this.#onMsg.delete(key);
+  }
+
+  #poll(state: ActiveStream<MsgBase, MsgBase>): void {
+    this.request(state.bind.msg, state.bind.opts)
+      .then((msg) => {
+        try {
+          state.controller?.enqueue(msg);
+          if (MsgIsError(msg)) {
+            state.controller?.close();
+          } else {
+            state.timeout = setTimeout(() => this.#poll(state), state.bind.opts.pollInterval ?? 1000);
+          }
+        } catch (err) {
+          state.controller?.error(err);
+          state.controller?.close();
+        }
+      })
+      .catch((err) => {
+        state.controller?.error(err);
+        // state.controller?.close();
+      });
+  }
+
+  readonly activeBinds = new Map<string, ActiveStream<MsgBase, MsgBase>>();
+  bind<Q extends MsgBase, S extends MsgBase>(req: Q, opts: RequestOpts): ReadableStream<MsgWithError<S>> {
+    const state: ActiveStream<S, Q> = {
+      id: this.sthis.nextId().str,
+      bind: {
+        msg: req,
+        opts,
+      },
+    } satisfies ActiveStream<S, Q>;
+    this.activeBinds.set(state.id, state);
+    return new ReadableStream<MsgWithError<S>>({
+      cancel: () => {
+        clearTimeout(state.timeout as number);
+        this.activeBinds.delete(state.id);
+      },
+      start: (controller) => {
+        state.controller = controller;
+        this.#poll(state);
+      },
+    });
+  }
+
+  // eslint-disable-next-line @typescript-eslint/no-unused-vars
+  async request<Q extends MsgBase, S extends MsgBase>(req: Q, _opts: RequestOpts): Promise<MsgWithError<S>> {
+    const headers = HttpHeader.from();
+    headers.Set("Content-Type", this.msgP.mime);
+    headers.Set("Accept", this.msgP.mime);
+
+    const rReqBody = exception2Result(() => this.msgP.ende.encode(req));
+    if (rReqBody.isErr()) {
+      return this.toMsg(
+        buildErrorMsg(this, req, this.logger.Error().Err(rReqBody.Err()).Any("req", req).Msg("encode error").AsError()),
+      );
+    }
+    headers.Set("Content-Length", rReqBody.Ok().byteLength.toString());
+    const url = selectRandom(this.baseURIs);
+    // console.log("request", url.cleaned.toString(), url.in.toString(), req);
+    this.logger.Debug().Any(url).Any("body", req).Msg("request");
+    const rRes = await exception2Result(() =>
+      timeout(
+        this.msgP.timeout,
+        fetch(url.cleaned.toString(), {
+          method: "PUT",
+          headers: headers.AsHeaderInit(),
+          body: rReqBody.Ok(),
+        }),
+      ),
+    );
+    this.logger.Debug().Any(url).Any("body", rRes).Msg("response");
+    if (rRes.isErr()) {
+      return this.toMsg(buildErrorMsg(this, req, this.logger.Error().Err(rRes).Any(url).Msg("fetch error").AsError()));
+    }
+    const res = rRes.Ok();
+    if (!res.ok) {
+      const data = new Uint8Array(await res.arrayBuffer());
+      const ret = await exception2Result(async () => this.msgP.ende.decode(data) as S);
+      if (ret.isErr() || !MsgIsError(ret.Ok())) {
+        return this.toMsg(
+          buildErrorMsg(
+            this,
+            req,
+            this.logger
+              .Error()
+              .Any(url)
+              .Str("status", res.status.toString())
+              .Str("statusText", res.statusText)
+              .Msg("HTTP Error")
+              .AsError(),
+            await res.text(),
+          ),
+        );
+      }
+      return this.toMsg(ret.Ok());
+    }
+    const data = new Uint8Array(await res.arrayBuffer());
+    const ret = await exception2Result(async () => this.msgP.ende.decode(data) as S);
+    if (ret.isErr()) {
+      return this.toMsg(
+        buildErrorMsg(this, req, this.logger.Error().Err(ret.Err()).Msg("decode error").AsError(), this.sthis.txt.decode(data)),
+      );
+    }
+    return this.toMsg(ret.Ok());
+  }
+
+  // toOnMessage<T extends MsgBase>(msg: WithErrorMsg<T>): Result<WithErrorMsg<T>> {
+  //   this.mec.msgFn?.(msg as unknown as MessageEvent<MsgBase>);
+  //   return Result.Ok(msg);
+  // }
+}
+++ b/src/protocols/cloud/index.ts
+export * from "./http-connection.js";
+export * from "./msg-raw-connection-base.js";
+export * from "./msg-types-data.js";
+export * from "./msg-types-meta.js";
+export * from "./msg-types-meta.js";
+export * from "./msg-types-wal.js";
+export * from "./msg-types.js";
+export * from "./msger.js";
+export * from "./ws-connection.js";
+++ b/src/protocols/cloud/msg-raw-connection-base.ts
+import { SuperThis } from "../../types.js";
+import { MsgBase, ErrorMsg, buildErrorMsg } from "./msg-types.js";
+import { ExchangedGestalt, OnErrorFn, UnReg } from "./msger.js";
+import { Logger } from "@adviser/cement";
+
+export class MsgRawConnectionBase {
+  readonly sthis: SuperThis;
+  readonly exchangedGestalt: ExchangedGestalt;
+
+  constructor(sthis: SuperThis, exGestalt: ExchangedGestalt) {
+    this.sthis = sthis;
+    this.exchangedGestalt = exGestalt;
+  }
+
+  readonly onErrorFns = new Map<string, OnErrorFn>();
+  onError(fn: OnErrorFn): UnReg {
+    const key = this.sthis.nextId().str;
+    this.onErrorFns.set(key, fn);
+    return () => this.onErrorFns.delete(key);
+  }
+
+  buildErrorMsg(
+    msgCtx: {
+      readonly logger: Logger;
+      readonly sthis: SuperThis;
+    },
+    msg: Partial<MsgBase>,
+    err: Error,
+  ): ErrorMsg {
+    // const logLine = this.sthis.logger.Error().Err(err).Any("msg", msg);
+    const rmsg = Array.from(this.onErrorFns.values()).reduce((msg, fn) => {
+      return fn(msg, err);
+    }, msg);
+    const emsg = buildErrorMsg(msgCtx, rmsg, err);
+    msgCtx.logger.Error().Err(err).Any("msg", rmsg).Msg("connection error");
+    return emsg;
+  }
+}
+++ b/src/protocols/cloud/msg-types-data.ts
+import { Result, URI } from "@adviser/cement";
+import {
+  ReqSignedUrl,
+  NextId,
+  MsgBase,
+  ResSignedUrl,
+  MsgWithError,
+  buildRes,
+  ReqSignedUrlParam,
+  buildReqSignedUrl,
+  GwCtx,
+  MsgIsTenantLedger,
+  MsgTypesCtx,
+  MsgWithConnAuth,
+  PreSignedMsg,
+} from "./msg-types.js";
+
+export interface ReqGetData extends ReqSignedUrl {
+  readonly type: "reqGetData";
+}
+
+export function buildReqGetData(sthis: NextId, sup: ReqSignedUrlParam, ctx: GwCtx): ReqGetData {
+  return buildReqSignedUrl<ReqGetData>(sthis, "reqGetData", sup, ctx);
+}
+
+export function MsgIsReqGetData(msg: MsgBase): msg is ReqGetData {
+  return msg.type === "reqGetData";
+}
+
+export interface ResGetData extends ResSignedUrl {
+  readonly type: "resGetData";
+  // readonly payload: Uint8Array; // transfered via JSON base64
+}
+
+export function MsgIsResGetData(msg: MsgBase): msg is ResGetData {
+  return msg.type === "resGetData" && MsgIsTenantLedger(msg);
+}
+
+export interface CalculatePreSignedUrl {
+  calculatePreSignedUrl(ctx: MsgTypesCtx, p: PreSignedMsg): Promise<Result<URI>>;
+}
+
+export function buildResGetData(
+  msgCtx: MsgTypesCtx,
+  req: MsgWithConnAuth<ReqGetData>,
+  ctx: CalculatePreSignedUrl,
+): Promise<MsgWithError<ResGetData>> {
+  return buildRes<MsgWithConnAuth<ReqGetData>, ResGetData>(
+    { method: "GET", store: req.methodParams.store },
+    "resGetData",
+    msgCtx,
+    req,
+    ctx,
+  );
+}
+
+export interface ReqPutData extends ReqSignedUrl {
+  readonly type: "reqPutData";
+  // readonly payload: Uint8Array; // transfered via JSON base64
+}
+
+export function MsgIsReqPutData(msg: MsgBase): msg is ReqPutData {
+  return msg.type === "reqPutData";
+}
+
+export function buildReqPutData(sthis: NextId, sup: ReqSignedUrlParam, ctx: GwCtx): ReqPutData {
+  return buildReqSignedUrl<ReqPutData>(sthis, "reqPutData", sup, ctx);
+}
+
+export interface ResPutData extends ResSignedUrl {
+  readonly type: "resPutData";
+}
+
+export function MsgIsResPutData(msg: MsgBase): msg is ResPutData {
+  return msg.type === "resPutData";
+}
+
+export function buildResPutData(
+  msgCtx: MsgTypesCtx,
+  req: MsgWithConnAuth<ReqPutData>,
+  ctx: CalculatePreSignedUrl,
+): Promise<MsgWithError<ResPutData>> {
+  return buildRes<MsgWithConnAuth<ReqPutData>, ResPutData>(
+    { method: "PUT", store: req.methodParams.store },
+    "resPutData",
+    msgCtx,
+    req,
+    ctx,
+  );
+}
+
+export interface ReqDelData extends ReqSignedUrl {
+  readonly type: "reqDelData";
+}
+
+export function MsgIsReqDelData(msg: MsgBase): msg is ReqDelData {
+  return msg.type === "reqDelData";
+}
+
+export function buildReqDelData(sthis: NextId, sup: ReqSignedUrlParam, ctx: GwCtx): ReqDelData {
+  return buildReqSignedUrl<ReqDelData>(sthis, "reqDelData", sup, ctx);
+}
+
+export interface ResDelData extends ResSignedUrl {
+  readonly type: "resDelData";
+}
+
+export function MsgIsResDelData(msg: MsgBase): msg is ResDelData {
+  return msg.type === "resDelData";
+}
+
+export function buildResDelData(
+  msgCtx: MsgTypesCtx,
+  req: MsgWithConnAuth<ReqDelData>,
+  ctx: CalculatePreSignedUrl,
+): Promise<MsgWithError<ResDelData>> {
+  return buildRes<MsgWithConnAuth<ReqDelData>, ResDelData>(
+    { method: "DELETE", store: req.methodParams.store },
+    "resDelData",
+    msgCtx,
+    req,
+    ctx,
+  );
+}
+++ b/src/protocols/cloud/msg-types-meta.ts
+import { VERSION } from "@adviser/cement";
+import {
+  AuthType,
+  GwCtx,
+  MsgBase,
+  MsgWithTenantLedger,
+  NextId,
+  ResOptionalSignedUrl,
+  MsgTypesCtx,
+  MsgWithConnAuth,
+  SignedUrlParam,
+  MethodSignedUrlParam,
+  ResSignedUrl,
+} from "./msg-types.js";
+import { V2SerializedMetaKey } from "../../runtime/meta-key-hack.js";
+
+/* Put Meta */
+export interface ReqPutMeta extends MsgWithTenantLedger<MsgWithConnAuth> {
+  readonly type: "reqPutMeta";
+  readonly methodParams: MethodSignedUrlParam;
+  readonly params: SignedUrlParam;
+  readonly meta: V2SerializedMetaKey;
+}
+
+export interface ResPutMeta extends MsgWithTenantLedger<MsgWithConnAuth>, ResSignedUrl {
+  readonly type: "resPutMeta";
+  // readonly signedUrl?: string;
+  readonly meta: V2SerializedMetaKey;
+}
+
+export function buildReqPutMeta(
+  sthis: NextId,
+  auth: AuthType,
+  signedUrlParams: SignedUrlParam,
+  meta: V2SerializedMetaKey,
+  gwCtx: GwCtx,
+): ReqPutMeta {
+  return {
+    auth,
+    tid: sthis.nextId().str,
+    type: "reqPutMeta",
+    ...gwCtx,
+    version: VERSION,
+    methodParams: {
+      method: "PUT",
+      store: "meta",
+    },
+    params: signedUrlParams,
+    meta,
+  };
+}
+
+export function MsgIsReqPutMeta(msg: MsgBase): msg is ReqPutMeta {
+  return msg.type === "reqPutMeta";
+}
+
+export function buildResPutMeta(
+  _msgCtx: MsgTypesCtx,
+  req: MsgWithTenantLedger<MsgWithConnAuth<ReqPutMeta>>,
+  meta: V2SerializedMetaKey,
+  signedUrl: string,
+): ResPutMeta {
+  return {
+    meta,
+    tid: req.tid,
+    conn: req.conn,
+    auth: req.auth,
+    methodParams: req.methodParams,
+    params: req.params,
+    tenant: req.tenant,
+    type: "resPutMeta",
+    signedUrl,
+    version: VERSION,
+  };
+}
+
+export function MsgIsResPutMeta(qs: MsgBase): qs is ResPutMeta {
+  return qs.type === "resPutMeta";
+}
+
+/* Bind Meta */
+export interface BindGetMeta extends MsgWithTenantLedger<MsgWithConnAuth> {
+  readonly type: "bindGetMeta";
+  readonly params: SignedUrlParam;
+}
+
+export function MsgIsBindGetMeta(msg: MsgBase): msg is BindGetMeta {
+  return msg.type === "bindGetMeta";
+}
+
+export interface EventGetMeta extends MsgWithTenantLedger<MsgWithConnAuth>, ResSignedUrl {
+  readonly type: "eventGetMeta";
+  readonly meta: V2SerializedMetaKey;
+}
+
+export function buildBindGetMeta(sthis: NextId, auth: AuthType, params: SignedUrlParam, gwCtx: GwCtx): BindGetMeta {
+  return {
+    auth,
+    tid: sthis.nextId().str,
+    ...gwCtx,
+    type: "bindGetMeta",
+    version: VERSION,
+    params,
+  };
+}
+
+export function buildEventGetMeta(
+  _msgCtx: MsgTypesCtx,
+  req: MsgWithTenantLedger<MsgWithConnAuth<BindGetMeta>>,
+  meta: V2SerializedMetaKey,
+  gwCtx: GwCtx,
+  signedUrl: string,
+): EventGetMeta {
+  return {
+    conn: gwCtx.conn,
+    tenant: req.tenant,
+    auth: req.auth,
+    tid: req.tid,
+    meta,
+    signedUrl,
+    type: "eventGetMeta",
+    params: req.params,
+    methodParams: { method: "GET", store: "meta" },
+    version: VERSION,
+  };
+}
+
+export function MsgIsEventGetMeta(qs: MsgBase): qs is EventGetMeta {
+  return qs.type === "eventGetMeta";
+}
+
+/* Del Meta */
+export interface ReqDelMeta extends MsgWithTenantLedger<MsgWithConnAuth> {
+  readonly type: "reqDelMeta";
+  readonly params: SignedUrlParam;
+  readonly meta?: V2SerializedMetaKey;
+}
+
+export function buildReqDelMeta(
+  sthis: NextId,
+  auth: AuthType,
+  params: SignedUrlParam,
+  gwCtx: GwCtx,
+  meta?: V2SerializedMetaKey,
+): ReqDelMeta {
+  return {
+    auth,
+    tid: sthis.nextId().str,
+    tenant: gwCtx.tenant,
+    conn: gwCtx.conn,
+    params,
+    meta,
+    type: "reqDelMeta",
+    version: VERSION,
+    // params: signedUrlParams,
+  };
+}
+
+export function MsgIsReqDelMeta(msg: MsgBase): msg is ReqDelMeta {
+  return msg.type === "reqDelMeta";
+}
+
+export interface ResDelMeta extends MsgWithTenantLedger<MsgWithConnAuth>, ResOptionalSignedUrl {
+  readonly type: "resDelMeta";
+}
+
+export function buildResDelMeta(
+  // msgCtx: MsgTypesCtx,
+  req: MsgWithTenantLedger<MsgWithConnAuth<ReqDelMeta>>,
+  params: SignedUrlParam,
+  signedUrl?: string,
+): ResDelMeta {
+  return {
+    auth: req.auth,
+    methodParams: { method: "DELETE", store: "meta" },
+    params,
+    signedUrl,
+    tid: req.tid,
+    conn: req.conn,
+    tenant: req.tenant,
+    type: "resDelMeta",
+    // key: req.key,
+    version: VERSION,
+  };
+}
+
+export function MsgIsResDelMeta(qs: MsgBase): qs is ResDelMeta {
+  return qs.type === "resDelMeta";
+}
+++ b/src/protocols/cloud/msg-types-wal.ts
+import {
+  MsgBase,
+  MsgWithError,
+  buildRes,
+  NextId,
+  ReqSignedUrl,
+  ResSignedUrl,
+  ReqSignedUrlParam,
+  buildReqSignedUrl,
+  GwCtx,
+  MsgIsTenantLedger,
+  MsgWithTenantLedger,
+  MsgTypesCtx,
+  MsgWithConnAuth,
+} from "./msg-types.js";
+import { CalculatePreSignedUrl } from "./msg-types-data.js";
+
+export interface ReqGetWAL extends ReqSignedUrl {
+  readonly type: "reqGetWAL";
+}
+
+export function MsgIsReqGetWAL(msg: MsgBase): msg is ReqGetWAL {
+  return msg.type === "reqGetWAL";
+}
+
+export function buildReqGetWAL(sthis: NextId, sup: ReqSignedUrlParam, ctx: GwCtx): ReqGetWAL {
+  return buildReqSignedUrl<ReqGetWAL>(sthis, "reqGetWAL", sup, ctx);
+}
+
+export interface ResGetWAL extends ResSignedUrl {
+  readonly type: "resGetWAL";
+  // readonly payload: Uint8Array; // transfered via JSON base64
+}
+
+export function MsgIsResGetWAL(msg: MsgBase): msg is ResGetWAL {
+  return msg.type === "resGetWAL";
+}
+
+export function buildResGetWAL(
+  msgCtx: MsgTypesCtx,
+  req: MsgWithTenantLedger<MsgWithConnAuth<ReqGetWAL>>,
+  ctx: CalculatePreSignedUrl,
+): Promise<MsgWithError<ResGetWAL>> {
+  return buildRes<MsgWithTenantLedger<MsgWithConnAuth<ReqGetWAL>>, ResGetWAL>(
+    { method: "GET", store: "wal" },
+    "resGetWAL",
+    msgCtx,
+    req,
+    ctx,
+  );
+}
+
+export interface ReqPutWAL extends Omit<ReqSignedUrl, "type"> {
+  readonly type: "reqPutWAL";
+  // readonly payload: Uint8Array; // transfered via JSON base64
+}
+
+export function MsgIsReqPutWAL(msg: MsgBase): msg is ReqPutWAL {
+  return msg.type === "reqPutWAL";
+}
+
+export function buildReqPutWAL(sthis: NextId, sup: ReqSignedUrlParam, ctx: GwCtx): ReqPutWAL {
+  return buildReqSignedUrl<ReqPutWAL>(sthis, "reqPutWAL", sup, ctx);
+}
+
+export interface ResPutWAL extends Omit<ResSignedUrl, "type"> {
+  readonly type: "resPutWAL";
+}
+
+export function MsgIsResPutWAL(msg: MsgBase): msg is ResPutWAL {
+  return msg.type === "resPutWAL";
+}
+
+export function buildResPutWAL(
+  msgCtx: MsgTypesCtx,
+  req: MsgWithTenantLedger<MsgWithConnAuth<ReqPutWAL>>,
+  ctx: CalculatePreSignedUrl,
+): Promise<MsgWithError<ResPutWAL>> {
+  return buildRes<MsgWithTenantLedger<MsgWithConnAuth<ReqPutWAL>>, ResPutWAL>(
+    { method: "PUT", store: "wal" },
+    "resPutWAL",
+    msgCtx,
+    req,
+    ctx,
+  );
+}
+
+export interface ReqDelWAL extends Omit<ReqSignedUrl, "type"> {
+  readonly type: "reqDelWAL";
+}
+
+export function MsgIsReqDelWAL(msg: MsgBase): msg is ReqDelWAL {
+  return msg.type === "reqDelWAL";
+}
+
+export function buildReqDelWAL(sthis: NextId, sup: ReqSignedUrlParam, ctx: GwCtx): ReqDelWAL {
+  return buildReqSignedUrl<ReqDelWAL>(sthis, "reqDelWAL", sup, ctx);
+}
+
+export interface ResDelWAL extends Omit<ResSignedUrl, "type"> {
+  readonly type: "resDelWAL";
+}
+
+export function MsgIsResDelWAL(msg: MsgBase): msg is ResDelWAL {
+  return msg.type === "resDelWAL" && MsgIsTenantLedger(msg);
+}
+
+export function buildResDelWAL(
+  msgCtx: MsgTypesCtx,
+  req: MsgWithTenantLedger<MsgWithConnAuth<ReqDelWAL>>,
+  ctx: CalculatePreSignedUrl,
+): Promise<MsgWithError<ResDelWAL>> {
+  return buildRes<MsgWithTenantLedger<MsgWithConnAuth<ReqDelWAL>>, ResDelWAL>(
+    { method: "DELETE", store: "wal" },
+    "resDelWAL",
+    msgCtx,
+    req,
+    ctx,
+  );
+}
+++ b/src/protocols/cloud/msg-types.ts
+import { Future, Logger, Result } from "@adviser/cement";
+import { SuperThis } from "@fireproof/core";
+import { CalculatePreSignedUrl } from "./msg-types-data.js";
+import type { JWTPayload } from "jose";
+// import { PreSignedMsg } from "./pre-signed-url.js";
+
+export const VERSION = "FP-MSG-1.0";
+
+export interface BaseTokenParam {
+  readonly alg: string; // defaults ES256
+  readonly issuer: string;
+  readonly audience: string;
+  readonly validFor: number;
+}
+
+export interface FPCloudClaim extends JWTPayload {
+  readonly userId: string;
+  readonly tenants: { readonly id: string; readonly role: string }[];
+  readonly ledgers: { readonly id: string; readonly role: string; readonly right: string }[];
+}
+
+export type TokenForParam = FPCloudClaim & Partial<BaseTokenParam>;
+
+export type MsgWithError<T extends MsgBase> = T | ErrorMsg;
+
+export interface PreSignedMsg extends MsgWithTenantLedger<MsgWithConnAuth> {
+  readonly methodParams: MethodSignedUrlParam;
+  readonly params: SignedUrlParam;
+}
+
+export interface RequestOpts {
+  readonly waitFor: (msg: MsgBase) => boolean;
+  readonly pollInterval?: number; // 1000ms
+  readonly timeout?: number; // ms
+}
+
+export interface EnDeCoder {
+  encode<T>(node: T): Uint8Array;
+  decode<T>(data: Uint8Array): T;
+}
+
+export interface WaitForTid {
+  readonly tid: string;
+  readonly future: Future<MsgBase>;
+  readonly timeout?: number;
+  // undefined match all
+  readonly waitFor: (msg: MsgBase) => boolean;
+}
+
+// export interface ConnId {
+//   readonly connId: string;
+// }
+// type AddConnId<T extends MsgBase, N> = Omit<T, "type"> & ConnId & { readonly type: N };
+export interface NextId {
+  readonly nextId: SuperThis["nextId"];
+}
+
+export interface AuthType {
+  readonly type: "ucan" | "error" | "fp-cloud-jwk" | "fp-cloud";
+}
+
+export function isAuthTypeFPCloudJWK(a: AuthType): a is FPJWKCloudAuthType {
+  return a.type === "fp-cloud-jwk";
+}
+
+export function isAuthTypeFPCloud(a: AuthType): a is FPCloudAuthType {
+  return a.type === "fp-cloud";
+}
+
+export interface UCanAuth extends AuthType {
+  readonly type: "ucan";
+  readonly params: {
+    readonly tbd: string;
+  };
+}
+export interface FPJWKCloudAuthType extends AuthType {
+  readonly type: "fp-cloud-jwk";
+  readonly params: {
+    readonly jwk: string;
+  };
+}
+
+export interface FPCloudAuthType extends AuthType {
+  readonly type: "fp-cloud";
+  readonly params: {
+    readonly claim: TokenForParam;
+    readonly jwk: string; // for reply
+  };
+}
+
+export type AuthFactory = (tp?: Partial<TokenForParam>) => Promise<Result<AuthType>>;
+
+export interface TenantLedger {
+  readonly tenant: string;
+  readonly ledger: string;
+}
+
+export function keyTenantLedger(t: TenantLedger): string {
+  return `${t.tenant}:${t.ledger}`;
+}
+
+export interface QSId {
+  readonly reqId: string;
+  readonly resId: string;
+}
+
+export function qsidEqual(a: QSId, b: QSId): boolean {
+  return a.reqId === b.reqId && a.resId === b.resId;
+}
+
+export function qsidKey(qsid: QSId): string {
+  return `${qsid.reqId}:${qsid.resId}`;
+}
+
+// export interface Connection extends ReqResId{
+//   readonly key: TenantLedger;
+// }
+
+// export interface Connected {
+//   readonly conn: Connection;
+// }
+
+export interface MsgBase {
+  readonly tid: string;
+  readonly type: string;
+  readonly version: string;
+  readonly auth: AuthType;
+}
+
+export function MsgIsTid(msg: MsgBase, tid: string): boolean {
+  return msg.tid === tid;
+}
+
+type MsgWithConn<T extends MsgBase = MsgBase> = T & { readonly conn: QSId };
+
+export type MsgWithConnAuth<T extends MsgBase = MsgBase> = MsgWithConn<T> & { readonly auth: AuthType };
+
+// type MsgWithOptionalConn<T extends MsgBase = MsgBase> = T & { readonly conn?: QSId };
+
+// export type MsgWithOptionalConnAuth<T extends MsgBase = MsgBase> = MsgWithOptionalConn<T> & { readonly auth: AuthType };
+
+export type MsgWithTenantLedger<T extends MsgWithConnAuth> = T & { readonly tenant: TenantLedger };
+
+export interface ErrorMsg extends MsgBase {
+  readonly type: "error";
+  readonly src: unknown;
+  readonly message: string;
+  readonly body?: string;
+  readonly stack?: string[];
+}
+
+export function MsgIsError(rq: MsgBase): rq is ErrorMsg {
+  return rq.type === "error";
+}
+
+export function MsgIsQSError(rq: ReqRes<MsgBase, MsgBase>): rq is ReqRes<ErrorMsg, ErrorMsg> {
+  return rq.res.type === "error" || rq.req.type === "error";
+}
+
+export type HttpMethods = "GET" | "PUT" | "DELETE";
+export type FPStoreTypes = "meta" | "car" | "wal" | "file";
+
+export function coerceFPStoreTypes(s?: string): FPStoreTypes {
+  const x = s?.trim();
+  if (x === "meta" || x === "car" || x === "wal" || x === "file") {
+    return x;
+  }
+  throw new Error(`Invalid FPStoreTypes: ${s}`);
+}
+
+// reqRes is http
+// stream is WebSocket
+export type ProtocolCapabilities = "reqRes" | "stream";
+
+export function isProtocolCapabilities(s: string): s is ProtocolCapabilities {
+  const x = s.trim();
+  return x === "reqRes" || x === "stream";
+}
+
+export interface Gestalt {
+  /**
+   * Describes StoreTypes which are handled
+   */
+  readonly storeTypes: FPStoreTypes[];
+  /**
+   * A unique identifier
+   */
+  readonly id: string;
+  /**
+   * protocol capabilities
+   * defaults "stream"
+   */
+  readonly protocolCapabilities: ProtocolCapabilities[];
+  /**
+   * HttpEndpoints (URL) required atleast one
+   * could be absolute or relative
+   */
+  readonly httpEndpoints: string[];
+  /**
+   * WebsocketEndpoints (URL) required atleast one
+   * could be absolute or relative
+   */
+  readonly wsEndpoints: string[];
+  /**
+   * Encodings supported
+   * JSON, CBOR
+   */
+  readonly encodings: ("JSON" | "CBOR")[];
+  /**
+   * Authentication methods supported
+   */
+  readonly auth: AuthType[];
+  /**
+   * Requires Authentication
+   */
+  readonly requiresAuth: boolean;
+  /**
+   * In|Outband Data | Meta | WAL Support
+   * Inband Means that the Payload is part of the message
+   * Outband Means that the Payload is PUT/GET to a different URL
+   * A Clien implementation usally not support reading or writing
+   * support
+   */
+  readonly data?: {
+    readonly inband: boolean;
+    readonly outband: boolean;
+  };
+  readonly meta?: {
+    readonly inband: true; // meta inband is mandatory
+    readonly outband: boolean;
+  };
+  readonly wal?: {
+    readonly inband: boolean;
+    readonly outband: boolean;
+  };
+  /**
+   * Request Types supported
+   * reqGestalt, reqSubscribeMeta, reqPutMeta, reqGetMeta, reqDelMeta, reqUpdateMeta
+   */
+  readonly reqTypes: string[];
+  /**
+   * Response Types supported
+   * resGestalt, resSubscribeMeta, resPutMeta, resGetMeta, resDelMeta, updateMeta
+   */
+  readonly resTypes: string[];
+  /**
+   * Event Types supported
+   * updateMeta
+   */
+  readonly eventTypes: string[];
+}
+
+export interface MsgerParams {
+  readonly mime: string;
+  readonly auth?: AuthType;
+  readonly hasPersistent?: boolean;
+  readonly protocolCapabilities?: ProtocolCapabilities[];
+  // readonly protocol: "http" | "ws";
+  readonly timeout: number; // msec
+}
+
+// force the server id
+export type GestaltParam = Partial<Gestalt> & { readonly id: string };
+
+export function defaultGestalt(msgP: MsgerParams, gestalt: GestaltParam): Gestalt {
+  return {
+    storeTypes: ["meta", "file", "car", "wal"],
+    httpEndpoints: ["/fp"],
+    wsEndpoints: ["/ws"],
+    encodings: ["JSON"],
+    protocolCapabilities: msgP.protocolCapabilities || ["reqRes", "stream"],
+    auth: [],
+    requiresAuth: false,
+    data: msgP.hasPersistent
+      ? {
+          inband: true,
+          outband: true,
+        }
+      : undefined,
+    meta: msgP.hasPersistent
+      ? {
+          inband: true,
+          outband: true,
+        }
+      : undefined,
+    wal: msgP.hasPersistent
+      ? {
+          inband: true,
+          outband: true,
+        }
+      : undefined,
+    reqTypes: [
+      "reqOpen",
+      "reqGestalt",
+      // "reqSignedUrl",
+      "reqSubscribeMeta",
+      "reqPutMeta",
+      "reqBindMeta",
+      "reqDelMeta",
+      "reqPutData",
+      "reqGetData",
+      "reqDelData",
+      "reqPutWAL",
+      "reqGetWAL",
+      "reqDelWAL",
+      "reqUpdateMeta",
+    ],
+    resTypes: [
+      "resOpen",
+      "resGestalt",
+      // "resSignedUrl",
+      "resSubscribeMeta",
+      "resPutMeta",
+      "resGetMeta",
+      "resDelMeta",
+      "resPutData",
+      "resGetData",
+      "resDelData",
+      "resPutWAL",
+      "resGetWAL",
+      "resDelWAL",
+      "updateMeta",
+    ],
+    eventTypes: ["updateMeta"],
+    ...gestalt,
+  };
+}
+
+export interface ReqChat extends MsgWithConn {
+  readonly type: "reqChat";
+  readonly message: string;
+  readonly targets: QSId[];
+}
+export interface ResChat extends MsgWithConn {
+  readonly type: "resChat";
+  readonly message: string;
+  readonly targets: QSId[];
+}
+
+export function buildReqChat(sthis: NextId, auth: AuthType, conn: QSId, message: string, targets?: QSId[]): ReqChat {
+  return {
+    tid: sthis.nextId().str,
+    type: "reqChat",
+    version: VERSION,
+    auth,
+    conn,
+    message,
+    targets: targets ?? [],
+  };
+}
+
+export function buildResChat(req: ReqChat, conn?: QSId, message?: string, targets?: QSId[], auth?: AuthType): ResChat {
+  return {
+    ...req,
+    auth: auth || req.auth,
+    conn: conn || req.conn,
+    message: message || req.message,
+    targets: targets || req.targets,
+    type: "resChat",
+    version: VERSION,
+  };
+}
+
+export function MsgIsReqChat(msg: MsgBase): msg is ReqChat {
+  return msg.type === "reqChat";
+}
+
+export function MsgIsResChat(msg: MsgBase): msg is ResChat {
+  return msg.type === "resChat";
+}
+
+/**
+ * The ReqGestalt message is used to request the
+ * features of the Responder.
+ */
+export interface ReqGestalt extends MsgBase {
+  readonly type: "reqGestalt";
+  readonly gestalt: Gestalt;
+  readonly publish?: boolean; // for testing
+}
+
+export function MsgIsReqGestalt(msg: MsgBase): msg is ReqGestalt {
+  return msg.type === "reqGestalt";
+}
+
+export function buildReqGestalt(sthis: NextId, auth: AuthType, gestalt: Gestalt, publish?: boolean): ReqGestalt {
+  return {
+    tid: sthis.nextId().str,
+    auth,
+    type: "reqGestalt",
+    version: VERSION,
+    gestalt,
+    publish,
+  };
+}
+
+export interface ConnInfo {
+  readonly connIds: string[];
+}
+/**
+ * The ResGestalt message is used to respond with
+ * the features of the Responder.
+ */
+export interface ResGestalt extends MsgBase {
+  readonly type: "resGestalt";
+  readonly gestalt: Gestalt;
+}
+
+export function buildResGestalt(req: ReqGestalt, gestalt: Gestalt, auth: AuthType): ResGestalt | ErrorMsg {
+  return {
+    tid: req.tid,
+    auth: auth || req.auth,
+    type: "resGestalt",
+    version: VERSION,
+    gestalt,
+  };
+}
+
+export function MsgIsResGestalt(msg: MsgBase): msg is ResGestalt {
+  return msg.type === "resGestalt";
+}
+
+export interface ReqOpenConnection {
+  // readonly key: TenantLedger;
+  readonly reqId?: string;
+  readonly resId?: string; // for double open
+}
+
+export interface ReqOpenConn {
+  readonly reqId: string;
+  readonly resId?: string;
+}
+
+export interface ReqOpen extends MsgBase {
+  readonly type: "reqOpen";
+  readonly conn: ReqOpenConn;
+}
+
+export function buildReqOpen(sthis: NextId, auth: AuthType, conn: ReqOpenConnection): ReqOpen {
+  return {
+    tid: sthis.nextId().str,
+    auth,
+    type: "reqOpen",
+    version: VERSION,
+    conn: {
+      ...conn,
+      reqId: conn.reqId || sthis.nextId().str,
+    },
+  };
+}
+
+// export function MsgIsReqOpenWithConn(imsg: MsgBase): imsg is MsgWithConn<ReqOpen> {
+//   const msg = imsg as MsgWithConn<ReqOpen>;
+//   return msg.type === "reqOpen" && !!msg.conn && !!msg.conn.reqId;
+// }
+
+export function MsgIsReqOpen(imsg: MsgBase): imsg is MsgWithConn<ReqOpen> {
+  const msg = imsg as MsgWithConn<ReqOpen>;
+  return msg.type === "reqOpen" && !!msg.conn && !!msg.conn.reqId;
+}
+
+export interface ResOpen extends MsgBase {
+  readonly type: "resOpen";
+  readonly conn: QSId;
+}
+
+export function MsgIsWithConn<T extends MsgBase>(msg: T): msg is MsgWithConn<T> {
+  const mwc = (msg as MsgWithConn<T>).conn;
+  return mwc && !!(mwc as QSId).reqId && !!(mwc as QSId).resId;
+}
+
+export function MsgIsWithConnAuth<T extends MsgBase>(msg: T): msg is MsgWithConnAuth<T> {
+  return MsgIsWithConn(msg) && !!msg.auth && typeof msg.auth.type === "string";
+}
+
+export function MsgIsConnected<T extends MsgBase>(msg: T, qsid: QSId): msg is MsgWithConn<T> {
+  return MsgIsWithConn(msg) && msg.conn.reqId === qsid.reqId && msg.conn.resId === qsid.resId;
+}
+
+export function buildResOpen(sthis: NextId, req: ReqOpen, resStreamId?: string): ResOpen {
+  if (!(req.conn && req.conn.reqId)) {
+    throw new Error("req.conn.reqId is required");
+  }
+  return {
+    ...req,
+    type: "resOpen",
+    conn: {
+      ...req.conn,
+      resId: req.conn.resId || resStreamId || sthis.nextId().str,
+    },
+  };
+}
+
+export function MsgIsResOpen(msg: MsgBase): msg is ResOpen {
+  return msg.type === "resOpen";
+}
+
+export interface ReqClose extends MsgWithConn {
+  readonly type: "reqClose";
+}
+
+export function MsgIsReqClose(msg: MsgBase): msg is ReqClose {
+  return msg.type === "reqClose" && MsgIsWithConn(msg);
+}
+
+export interface ResClose extends MsgWithConn {
+  readonly type: "resClose";
+}
+
+export function MsgIsResClose(msg: MsgBase): msg is ResClose {
+  return msg.type === "resClose" && MsgIsWithConn(msg);
+}
+
+export function buildResClose(req: ReqClose, conn: QSId): ResClose {
+  return {
+    ...req,
+    type: "resClose",
+    conn,
+  };
+}
+
+export function buildReqClose(sthis: NextId, auth: AuthType, conn: QSId): ReqClose {
+  return {
+    tid: sthis.nextId().str,
+    auth,
+    type: "reqClose",
+    version: VERSION,
+    conn,
+  };
+}
+
+export interface SignedUrlParam {
+  // base path
+  readonly path?: string;
+  // name of the file
+  readonly key: string;
+  readonly expires?: number; // seconds
+  readonly index?: string;
+}
+
+export interface MethodSignedUrlParam {
+  readonly method: HttpMethods;
+  readonly store: FPStoreTypes;
+}
+
+// export type ReqSignedUrlParam = Omit<SignedUrlParam, "method" | "store">;
+export interface ReqSignedUrlParam {
+  readonly auth: AuthType;
+  readonly methodParam: MethodSignedUrlParam;
+  readonly params: SignedUrlParam;
+}
+
+export interface UpdateReqRes<Q extends MsgBase, S extends MsgBase> {
+  req: Q;
+  res: S;
+}
+
+export type ReqRes<Q extends MsgBase, S extends MsgBase> = Readonly<UpdateReqRes<Q, S>>;
+
+export function buildErrorMsg(
+  msgCtx: { readonly logger: Logger; readonly sthis: SuperThis },
+  base: Partial<MsgBase & { ref?: unknown }>,
+  error: Error,
+  body?: string,
+  stack?: string[],
+): ErrorMsg {
+  if (!stack && msgCtx.sthis.env.get("FP_STACK")) {
+    stack = error.stack?.split("\n");
+  }
+  const msg = {
+    auth: base.auth || { type: "error" },
+    src: base,
+    type: "error",
+    tid: base.tid || "internal",
+    message: error.message,
+    version: VERSION,
+    body,
+    stack,
+  } satisfies ErrorMsg;
+  msgCtx.logger.Any("ErrorMsg", msg);
+  return msg;
+}
+
+export function MsgIsTenantLedger<T extends MsgBase>(msg: T): msg is MsgWithTenantLedger<MsgWithConnAuth<T>> {
+  if (MsgIsWithConnAuth(msg)) {
+    const t = (msg as MsgWithTenantLedger<MsgWithConnAuth<T>>).tenant;
+    return !!t && !!t.tenant && !!t.ledger;
+  }
+  return false;
+}
+
+export interface ReqSignedUrl extends ReqSignedUrlWithoutMethodParams {
+  // readonly type: "reqSignedUrl";
+  readonly methodParams: MethodSignedUrlParam;
+}
+
+export interface ReqSignedUrlWithoutMethodParams extends MsgWithTenantLedger<MsgWithConnAuth> {
+  readonly params: SignedUrlParam;
+}
+
+export interface GwCtx {
+  readonly tid?: string;
+  readonly conn: QSId;
+  readonly tenant: TenantLedger;
+}
+
+export interface GwCtxConn {
+  readonly tid?: string;
+  readonly conn: QSId;
+  readonly tenant: TenantLedger;
+}
+
+export function buildReqSignedUrl<T extends ReqSignedUrl>(sthis: NextId, type: string, rparam: ReqSignedUrlParam, gwCtx: GwCtx): T {
+  return {
+    tid: sthis.nextId().str,
+    type,
+    auth: rparam.auth,
+    methodParams: rparam.methodParam,
+    version: VERSION,
+    ...gwCtx,
+    params: rparam.params,
+  } satisfies ReqSignedUrl as T;
+}
+
+export interface ResSignedUrl extends MsgWithTenantLedger<MsgWithConn> {
+  // readonly type: "resSignedUrl";
+  readonly methodParams: MethodSignedUrlParam;
+  readonly params: SignedUrlParam;
+  readonly signedUrl: string;
+}
+
+export interface ResOptionalSignedUrl extends MsgWithTenantLedger<MsgWithConn> {
+  // readonly type: "resSignedUrl";
+  readonly params: SignedUrlParam;
+  readonly methodParams: MethodSignedUrlParam;
+  readonly signedUrl?: string;
+}
+
+export interface MsgTypesCtx {
+  readonly sthis: SuperThis;
+  readonly logger: Logger;
+  // readonly auth: AuthFactory;
+}
+
+// export async function msgTypesCtxSync(msgCtx: MsgTypesCtx): Promise<MsgTypesCtxSync> {
+//   return {
+//     sthis: msgCtx.sthis,
+//     logger: msgCtx.logger,
+//     auth: await msgCtx.auth(),
+//   };
+// }
+
+export interface MsgTypesCtxSync {
+  readonly sthis: SuperThis;
+  readonly logger: Logger;
+  readonly auth: AuthType;
+}
+
+export function resAuth(msg: MsgBase): Promise<AuthType> {
+  return msg.auth ? Promise.resolve(msg.auth) : Promise.reject(new Error("No Auth"));
+}
+
+export async function buildRes<Q extends MsgWithTenantLedger<MsgWithConn<ReqSignedUrlWithoutMethodParams>>, S extends ResSignedUrl>(
+  methodParams: MethodSignedUrlParam,
+  type: string,
+  msgCtx: MsgTypesCtx,
+  req: Q,
+  ctx: CalculatePreSignedUrl,
+): Promise<MsgWithError<S>> {
+  const psm = {
+    type: "reqSignedUrl",
+    auth: await resAuth(req),
+    version: req.version,
+    methodParams,
+    params: {
+      ...req.params,
+    },
+    conn: req.conn,
+    tenant: req.tenant,
+    tid: req.tid,
+  } satisfies PreSignedMsg;
+  const rSignedUrl = await ctx.calculatePreSignedUrl(msgCtx, psm);
+  if (rSignedUrl.isErr()) {
+    return buildErrorMsg(msgCtx, req, rSignedUrl.Err());
+  }
+  return {
+    ...req,
+    params: psm.params,
+    methodParams,
+    type,
+    signedUrl: rSignedUrl.Ok().toString(),
+  } as unknown as MsgWithError<S>;
+}
+++ b/src/protocols/cloud/msger.ts
+import { BuildURI, CoerceURI, Logger, Result, runtimeFn, URI } from "@adviser/cement";
+import {
+  buildReqGestalt,
+  defaultGestalt,
+  EnDeCoder,
+  Gestalt,
+  MsgBase,
+  MsgerParams,
+  MsgIsResGestalt,
+  RequestOpts,
+  ResGestalt,
+  MsgWithError,
+  MsgWithConnAuth,
+  buildReqOpen,
+  MsgIsConnected,
+  MsgIsError,
+  MsgIsResOpen,
+  QSId,
+  MsgIsTid,
+  ReqGestalt,
+  buildReqClose,
+  MsgIsResClose,
+  AuthFactory,
+  AuthType,
+  FPJWKCloudAuthType,
+} from "./msg-types.js";
+import { HttpConnection } from "./http-connection.js";
+import { WSConnection } from "./ws-connection.js";
+import { SuperThis } from "../../types.js";
+
+// const headers = {
+//     "Content-Type": "application/json",
+//     "Accept": "application/json",
+// };
+
+export function selectRandom<T>(arr: T[]): T {
+  return arr[Math.floor(Math.random() * arr.length)];
+}
+
+export function timeout<T>(ms: number, promise: Promise<T>): Promise<T> {
+  return new Promise((resolve, reject) => {
+    const timer = setTimeout(() => {
+      reject(new Error(`TIMEOUT after ${ms}ms`));
+    }, ms);
+    promise
+      .then(resolve)
+      .catch(reject)
+      .finally(() => clearTimeout(timer));
+  });
+}
+
+export type OnMsgFn<T extends MsgBase = MsgBase> = (msg: MsgWithError<T>) => void;
+export type UnReg = () => void;
+
+export interface ExchangedGestalt {
+  readonly my: Gestalt;
+  readonly remote: Gestalt;
+}
+
+export type OnErrorFn = (msg: Partial<MsgBase>, err: Error) => Partial<MsgBase>;
+
+export interface ActiveStream<S extends MsgBase, Q extends MsgBase> {
+  readonly id: string;
+  readonly bind: {
+    readonly msg: Q;
+    readonly opts: RequestOpts;
+  };
+  timeout?: unknown;
+  controller?: ReadableStreamDefaultController<MsgWithError<S>>;
+}
+
+export interface MsgRawConnection<T extends MsgBase = MsgBase> {
+  // readonly ws: WebSocket;
+  // readonly params: ConnectionKey;
+  // qsOpen: ReqRes<ReqOpen, ResOpen>;
+  readonly sthis: SuperThis;
+  readonly exchangedGestalt: ExchangedGestalt;
+  readonly activeBinds: Map<string, ActiveStream<T, MsgBase>>;
+  bind<S extends T, Q extends T>(req: Q, opts: RequestOpts): ReadableStream<MsgWithError<S>>;
+  request<S extends T, Q extends T>(req: Q, opts: RequestOpts): Promise<MsgWithError<S>>;
+  send<S extends T, Q extends T>(msg: Q): Promise<MsgWithError<S>>;
+  start(): Promise<Result<void>>;
+  close(o: T): Promise<Result<void>>;
+  onMsg(msg: OnMsgFn<T>): UnReg;
+}
+
+export function jsonEnDe(sthis: SuperThis): EnDeCoder {
+  return {
+    encode: (node: unknown) => sthis.txt.encode(JSON.stringify(node)),
+    decode: (data: Uint8Array) => JSON.parse(sthis.txt.decode(data)),
+  };
+}
+
+export type MsgerParamsWithEnDe = MsgerParams & { readonly ende: EnDeCoder };
+
+export function defaultMsgParams(sthis: SuperThis, igs: Partial<MsgerParamsWithEnDe>): MsgerParamsWithEnDe {
+  return {
+    mime: "application/json",
+    ende: jsonEnDe(sthis),
+    timeout: 3000,
+    protocolCapabilities: ["reqRes", "stream"],
+    ...igs,
+  } satisfies MsgerParamsWithEnDe;
+}
+
+export interface OpenParams {
+  readonly timeout: number;
+}
+
+export async function applyStart(prC: Promise<Result<MsgRawConnection>>): Promise<Result<MsgRawConnection>> {
+  const rC = await prC;
+  if (rC.isErr()) {
+    return rC;
+  }
+  const c = rC.Ok();
+  const r = await c.start();
+  if (r.isErr()) {
+    return Result.Err(r.Err());
+  }
+  return rC;
+}
+
+export async function authTypeFromUri(logger: Logger, curi: CoerceURI): Promise<Result<FPJWKCloudAuthType>> {
+  const uri = URI.from(curi);
+  const authJWK = uri.getParam("authJWK");
+  if (!authJWK) {
+    return logger.Error().Url(uri).Msg("authJWK is required").ResultError();
+  }
+  // const sts = await SessionTokenService.createFromEnv();
+  // const fpc = await sts.validate(authJWK);
+  // if (fpc.isErr()) {
+  //   return logger.Error().Err(fpc).Msg("Invalid authJWK").ResultError();
+  // }
+  return Result.Ok({
+    type: "fp-cloud-jwk",
+    params: {
+      // claim: fpc.Ok().payload,
+      jwk: authJWK,
+    },
+  } satisfies FPJWKCloudAuthType);
+}
+
+export class MsgConnected {
+  static async connect(
+    auth: AuthType,
+    mrc: Result<MsgRawConnection> | MsgRawConnection,
+    conn: Partial<QSId> = {},
+  ): Promise<Result<MsgConnected>> {
+    if (Result.Is(mrc)) {
+      if (mrc.isErr()) {
+        return Result.Err(mrc.Err());
+      }
+      mrc = mrc.Ok();
+    }
+    const res = await mrc.request(buildReqOpen(mrc.sthis, auth, conn), { waitFor: MsgIsResOpen });
+    if (MsgIsError(res) || !MsgIsResOpen(res)) {
+      return mrc.sthis.logger.Error().Err(res).Msg("unexpected response").ResultError();
+    }
+    return Result.Ok(new MsgConnected(mrc, res.conn));
+  }
+
+  readonly sthis: SuperThis;
+  readonly conn: QSId;
+  readonly raw: MsgRawConnection;
+  readonly exchangedGestalt: ExchangedGestalt;
+  readonly activeBinds: Map<string, ActiveStream<MsgWithConnAuth, MsgBase>>;
+  readonly id: string;
+  private constructor(raw: MsgRawConnection, conn: QSId) {
+    this.sthis = raw.sthis;
+    this.raw = raw;
+    this.exchangedGestalt = raw.exchangedGestalt;
+    this.conn = conn;
+    this.activeBinds = raw.activeBinds;
+    this.id = this.sthis.nextId().str;
+  }
+
+  attachAuth(auth: AuthFactory): MsgConnectedAuth {
+    return new MsgConnectedAuth(this, auth);
+  }
+}
+
+export class MsgConnectedAuth implements MsgRawConnection<MsgWithConnAuth> {
+  readonly sthis: SuperThis;
+  readonly conn: QSId;
+  readonly raw: MsgRawConnection;
+  readonly exchangedGestalt: ExchangedGestalt;
+  readonly activeBinds: Map<string, ActiveStream<MsgWithConnAuth, MsgBase>>;
+  readonly id: string;
+  readonly authFactory: AuthFactory;
+
+  constructor(conn: MsgConnected, authFactory: AuthFactory) {
+    this.id = conn.id;
+    this.raw = conn.raw;
+    this.conn = conn.conn;
+    this.sthis = conn.sthis;
+    this.authFactory = authFactory;
+    this.exchangedGestalt = conn.exchangedGestalt;
+    this.activeBinds = conn.activeBinds;
+  }
+
+  bind<S extends MsgWithConnAuth, Q extends MsgWithConnAuth>(req: Q, opts: RequestOpts): ReadableStream<MsgWithError<S>> {
+    const stream = this.raw.bind({ ...req, conn: req.conn || this.conn }, opts);
+    const ts = new TransformStream<MsgWithError<S>, MsgWithError<S>>({
+      transform: (chunk, controller) => {
+        if (!MsgIsTid(chunk, req.tid)) {
+          return;
+        }
+        if (MsgIsConnected(chunk, this.conn)) {
+          if (opts.waitFor?.(chunk) || MsgIsError(chunk)) {
+            controller.enqueue(chunk);
+          }
+        }
+      },
+    });
+
+    // why the hell pipeTo sends an error that is undefined?
+    stream.pipeThrough(ts);
+    // stream.pipeTo(ts.writable).catch((err) => err && err.message && console.error("bind error", err));
+    return ts.readable;
+  }
+
+  authType(): Promise<Result<AuthType>> {
+    return this.authFactory();
+  }
+
+  msgConnAuth(): Promise<Result<MsgWithConnAuth>> {
+    return this.authType().then((r) => {
+      if (r.isErr()) {
+        return Result.Err(r);
+      }
+      return Result.Ok({ conn: this.conn, auth: r.Ok() } as MsgWithConnAuth);
+    });
+  }
+
+  request<S extends MsgWithConnAuth, Q extends MsgWithConnAuth>(req: Q, opts: RequestOpts): Promise<MsgWithError<S>> {
+    return this.raw.request({ ...req, conn: req.conn || this.conn }, opts);
+  }
+
+  send<S extends MsgWithConnAuth, Q extends MsgWithConnAuth>(msg: Q): Promise<MsgWithError<S>> {
+    return this.raw.send({ ...msg, conn: msg.conn || this.conn });
+  }
+
+  start(): Promise<Result<void>> {
+    return this.raw.start();
+  }
+  async close(t: MsgWithConnAuth): Promise<Result<void>> {
+    await this.request(buildReqClose(this.sthis, t.auth, this.conn), { waitFor: MsgIsResClose });
+    return await this.raw.close(t);
+    // return Result.Ok(undefined);
+  }
+  onMsg(msgFn: OnMsgFn<MsgWithConnAuth>): UnReg {
+    return this.raw.onMsg((msg) => {
+      if (MsgIsConnected(msg, this.conn)) {
+        msgFn(msg);
+      }
+    });
+  }
+}
+
+function initialFPUri(curl: CoerceURI): URI {
+  let gestaltUrl = URI.from(curl);
+  if (["", "/"].includes(gestaltUrl.pathname)) {
+    gestaltUrl = gestaltUrl.build().appendRelative("/fp").URI();
+  }
+  return gestaltUrl;
+}
+
+// eslint-disable-next-line @typescript-eslint/no-extraneous-class
+export class Msger {
+  static async openHttp(
+    sthis: SuperThis,
+    // reqOpen: ReqOpen | undefined,
+    urls: URI[],
+    msgP: MsgerParamsWithEnDe,
+    exGestalt: ExchangedGestalt,
+  ): Promise<Result<MsgRawConnection>> {
+    return Result.Ok(new HttpConnection(sthis, urls, msgP, exGestalt));
+  }
+  static async openWS(
+    sthis: SuperThis,
+    // qOpen: ReqOpen,
+    url: URI,
+    msgP: MsgerParamsWithEnDe,
+    exGestalt: ExchangedGestalt,
+  ): Promise<Result<MsgRawConnection>> {
+    let ws: WebSocket;
+    // const { encode } = jsonEnDe(sthis);
+    url = url.build().setParam("random", sthis.nextId().str).URI();
+    // console.log("openWS", url.toString());
+    // .setParam("reqOpen", sthis.txt.decode(encode(qOpen)))
+    if (runtimeFn().isNodeIsh) {
+      const { WebSocket } = await import("ws");
+      ws = new WebSocket(url.toString()) as unknown as WebSocket;
+    } else {
+      ws = new WebSocket(url.toString());
+    }
+    return Result.Ok(new WSConnection(sthis, ws, msgP, exGestalt));
+  }
+  static async open(
+    sthis: SuperThis,
+    auth: AuthType,
+    curl: CoerceURI,
+    imsgP: Partial<MsgerParamsWithEnDe> = {},
+  ): Promise<Result<MsgRawConnection>> {
+    // initial exchange with JSON encoding
+    const jsMsgP = defaultMsgParams(sthis, { ...imsgP, mime: "application/json", ende: jsonEnDe(sthis) });
+    const gestaltUrl = initialFPUri(curl);
+    const gs = defaultGestalt(defaultMsgParams(sthis, imsgP), { id: "FP-Universal-Client" });
+    /*
+     * request Gestalt with Http
+     */
+    const rHC = await Msger.openHttp(sthis, [gestaltUrl], jsMsgP, { my: gs, remote: gs });
+    if (rHC.isErr()) {
+      return rHC;
+    }
+    const hc = rHC.Ok();
+    // const rAuth = await authTypeFromUri(sthis.logger, url);
+    // if (rAuth.isErr()) {
+    //   return Result.Err(rAuth)
+    // }
+    const resGestalt = await hc.request<ResGestalt, ReqGestalt>(buildReqGestalt(sthis, auth, gs), {
+      waitFor: MsgIsResGestalt,
+    });
+    if (!MsgIsResGestalt(resGestalt)) {
+      return sthis.logger.Error().Any({ resGestalt }).Msg("should be ResGestalt").ResultError();
+    }
+    await hc.close(resGestalt /* as MsgWithConnAuth */);
+    const exGt = { my: gs, remote: resGestalt.gestalt } satisfies ExchangedGestalt;
+    const msgP = defaultMsgParams(sthis, imsgP);
+    if (exGt.remote.protocolCapabilities.includes("reqRes") && !exGt.remote.protocolCapabilities.includes("stream")) {
+      // console.log("openHttp---", exGt.remote.httpEndpoints, curl?.toString(), exGt.remote.httpEndpoints.map((i) => BuildURI.from(curl).resolve(i).URI().toString()));
+      return applyStart(
+        Msger.openHttp(
+          sthis,
+          exGt.remote.httpEndpoints.map((i) => BuildURI.from(curl).resolve(i).URI()),
+          msgP,
+          exGt,
+        ),
+      );
+    }
+    const wsUrl = BuildURI.from(gestaltUrl).resolve(selectRandom(exGt.remote.wsEndpoints)).URI();
+    // console.log("openWS---", wsUrl.toString(), "=====", exGt.remote.wsEndpoints);
+    return applyStart(Msger.openWS(sthis, wsUrl, msgP, exGt));
+  }
+
+  static connect(
+    sthis: SuperThis,
+    auth: AuthType,
+    curl: CoerceURI,
+    imsgP: Partial<MsgerParamsWithEnDe> = {},
+    conn: Partial<QSId> = {},
+  ): Promise<Result<MsgConnected>> {
+    return Msger.open(sthis, auth, curl, imsgP).then((srv) => MsgConnected.connect(auth, srv, conn));
+  }
+
+  private constructor() {
+    /* */
+  }
+}
+++ b/src/protocols/cloud/ws-connection.ts
+import { exception2Result, Future, Logger, Result } from "@adviser/cement";
+import { MsgBase, MsgIsError, buildErrorMsg, ReqOpen, WaitForTid, MsgWithError, RequestOpts, MsgIsTid } from "./msg-types.js";
+import { ActiveStream, ExchangedGestalt, MsgerParamsWithEnDe, MsgRawConnection, OnMsgFn, UnReg } from "./msger.js";
+import { MsgRawConnectionBase } from "./msg-raw-connection-base.js";
+import { SuperThis } from "../../types.js";
+import { ensureLogger } from "../../utils.js";
+
+export interface WSReqOpen {
+  readonly reqOpen: ReqOpen;
+  readonly ws: WebSocket; // this WS is opened with a specific URL-Param
+}
+
+export class WSConnection extends MsgRawConnectionBase implements MsgRawConnection {
+  readonly logger: Logger;
+  readonly msgP: MsgerParamsWithEnDe;
+  readonly ws: WebSocket;
+  // readonly baseURI: URI;
+
+  readonly #onMsg = new Map<string, OnMsgFn>();
+  readonly #onClose = new Map<string, UnReg>();
+
+  readonly waitForTid = new Map<string, WaitForTid>();
+
+  opened = false;
+
+  readonly id: string;
+
+  constructor(sthis: SuperThis, ws: WebSocket, msgP: MsgerParamsWithEnDe, exGestalt: ExchangedGestalt) {
+    super(sthis, exGestalt);
+    this.id = sthis.nextId().str;
+    this.logger = ensureLogger(sthis, "WSConnection");
+    this.msgP = msgP;
+    this.ws = ws;
+    // this.wqs = { ...wsq };
+  }
+
+  async start(): Promise<Result<void>> {
+    const onOpenFuture: Future<Result<unknown>> = new Future<Result<unknown>>();
+    const timer = setTimeout(() => {
+      const err = this.logger.Error().Dur("timeout", this.msgP.timeout).Msg("Timeout").AsError();
+      this.toMsg(buildErrorMsg(this, {} as MsgBase, err));
+      onOpenFuture.resolve(Result.Err(err));
+    }, this.msgP.timeout);
+    this.ws.onopen = () => {
+      onOpenFuture.resolve(Result.Ok(undefined));
+      this.opened = true;
+    };
+    this.ws.onerror = (ierr) => {
+      const err = this.logger.Error().Err(ierr).Msg("WS Error").AsError();
+      onOpenFuture.resolve(Result.Err(err));
+      const res = this.buildErrorMsg(this, {}, err);
+      this.toMsg(res);
+    };
+    this.ws.onmessage = (evt) => {
+      if (!this.opened) {
+        this.toMsg(buildErrorMsg(this, {} as MsgBase, this.logger.Error().Msg("Received message before onOpen").AsError()));
+      }
+      this.#wsOnMessage(evt);
+    };
+    this.ws.onclose = () => {
+      this.opened = false;
+      // console.log("onclose", this.id);
+      this.close().catch((ierr) => {
+        const err = this.logger.Error().Err(ierr).Msg("close error").AsError();
+        onOpenFuture.resolve(Result.Err(err));
+        this.toMsg(buildErrorMsg(this, { tid: "internal" } as MsgBase, err));
+      });
+    };
+    /* wait for onOpen */
+    const rOpen = await onOpenFuture.asPromise().finally(() => {
+      clearTimeout(timer);
+    });
+    if (rOpen.isErr()) {
+      return rOpen;
+    }
+    // const resOpen = await this.request(this.wqs.reqOpen, { waitFor: MsgIsResOpen });
+    // if (!MsgIsResOpen(resOpen)) {
+    //   return Result.Err(this.logger.Error().Any("ErrMsg", resOpen).Msg("Invalid response").AsError());
+    // }
+    // this.wqs.resOpen = resOpen;
+    return Result.Ok(undefined);
+  }
+
+  readonly #wsOnMessage = async (event: MessageEvent) => {
+    const rMsg = await exception2Result(() => this.msgP.ende.decode(event.data) as MsgBase);
+    if (rMsg.isErr()) {
+      this.logger.Error().Err(rMsg).Any(event.data).Msg("Invalid message");
+      return;
+    }
+    const msg = rMsg.Ok();
+    const waitFor = this.waitForTid.get(msg.tid);
+    Array.from(this.#onMsg.values()).forEach((cb) => {
+      // console.log("cb-onmessage", this.id, msg, cb.toString());
+      cb(msg);
+    });
+    if (waitFor) {
+      if (MsgIsError(msg)) {
+        this.waitForTid.delete(msg.tid);
+        waitFor.future.resolve(msg);
+      } else if (waitFor.waitFor(msg)) {
+        // what for a specific type
+        this.waitForTid.delete(msg.tid);
+        waitFor.future.resolve(msg);
+      } else {
+        // wild-card
+        this.waitForTid.delete(msg.tid);
+        waitFor.future.resolve(msg);
+      }
+    }
+  };
+
+  async close(): Promise<Result<void>> {
+    this.#onClose.forEach((fn) => fn());
+    this.#onClose.clear();
+    this.#onMsg.clear();
+    this.ws.close();
+    return Result.Ok(undefined);
+  }
+
+  toMsg<S extends MsgBase>(msg: MsgWithError<S>): MsgWithError<S> {
+    this.#onMsg.forEach((fn) => fn(msg));
+    return msg;
+  }
+
+  send<Q extends MsgBase, S extends MsgBase>(msg: Q): Promise<S> {
+    this.ws.send(this.msgP.ende.encode(msg));
+    return Promise.resolve(msg as unknown as S);
+  }
+
+  onMsg<S extends MsgBase>(fn: OnMsgFn<S>): UnReg {
+    const key = this.sthis.nextId().str;
+    this.#onMsg.set(key, fn as OnMsgFn);
+    return () => this.#onMsg.delete(key);
+  }
+
+  onClose(fn: UnReg): UnReg {
+    const key = this.sthis.nextId().str;
+    this.#onClose.set(key, fn);
+    return () => this.#onClose.delete(key);
+  }
+
+  readonly activeBinds = new Map<string, ActiveStream<MsgBase, MsgBase>>();
+  bind<Q extends MsgBase, S extends MsgBase>(req: Q, opts: RequestOpts): ReadableStream<MsgWithError<S>> {
+    const state: ActiveStream<S, Q> = {
+      id: this.sthis.nextId().str,
+      bind: {
+        msg: req,
+        opts,
+      },
+      // timeout: undefined,
+      // controller: undefined,
+    } satisfies ActiveStream<S, Q>;
+    this.activeBinds.set(state.id, state);
+    return new ReadableStream<MsgWithError<S>>({
+      cancel: () => {
+        // clearTimeout(state.timeout as number);
+        this.activeBinds.delete(state.id);
+      },
+      start: (controller) => {
+        this.onMsg<S>((msg) => {
+          if (MsgIsError(msg)) {
+            controller.enqueue(msg);
+            return;
+          }
+          if (!MsgIsTid(msg, req.tid)) {
+            return;
+          }
+          if (opts.waitFor && opts.waitFor(msg)) {
+            controller.enqueue(msg);
+          }
+        });
+        this.send(req);
+        const future = new Future<S>();
+        this.waitForTid.set(req.tid, { tid: req.tid, future, waitFor: opts.waitFor, timeout: opts.timeout });
+        future.asPromise().then((msg) => {
+          if (MsgIsError(msg)) {
+            // double err emitting
+            controller.enqueue(msg);
+            controller.close();
+          }
+        });
+      },
+    });
+  }
+
+  async request<Q extends MsgBase, S extends MsgBase>(req: Q, opts: RequestOpts): Promise<MsgWithError<S>> {
+    if (!this.opened) {
+      return buildErrorMsg(this, req, this.logger.Error().Msg("Connection not open").AsError());
+    }
+    const future = new Future<S>();
+    this.waitForTid.set(req.tid, { tid: req.tid, future, waitFor: opts.waitFor, timeout: opts.timeout });
+    await this.send(req);
+    return future.asPromise();
+  }
+
+  // toOnMessage<T extends MsgBase>(msg: WithErrorMsg<T>): Result<WithErrorMsg<T>> {
+  //   this.mec.msgFn?.(msg as unknown as MessageEvent<MsgBase>);
+  //   return Result.Ok(msg);
+  // }
+}
+++ b/src/protocols/index.ts
+export * as cloud from "./cloud/index.js";
+++ b/src/react/img-file.ts
+const { URL } = globalThis;
+++ b/src/runtime/gateways/cloud/gateway.ts
+// import PartySocket, { PartySocketOptions } from "partysocket";
+import {
+  Result,
+  URI,
+  KeyedResolvOnce,
+  exception2Result,
+  Logger,
+  param,
+  MatchResult,
+  ResolveOnce,
+  to_uint8,
+  CoerceURI,
+} from "@adviser/cement";
+import type { Attachable, GatewayUrlsParam, SuperThis } from "../../../types.js";
+import {
+  buildErrorMsg,
+  buildReqOpen,
+  FPStoreTypes,
+  HttpMethods,
+  MsgBase,
+  MsgIsError,
+  ReqSignedUrl,
+  MsgWithError,
+  ResSignedUrl,
+  GwCtx,
+  QSId,
+  coerceFPStoreTypes,
+} from "../../../protocols/cloud/msg-types.js";
+import { MsgConnected, MsgConnectedAuth, Msger, authTypeFromUri } from "../../../protocols/cloud/msger.js";
+import {
+  MsgIsResDelData,
+  MsgIsResGetData,
+  MsgIsResPutData,
+  ResDelData,
+  ResGetData,
+  ResPutData,
+} from "../../../protocols/cloud/msg-types-data.js";
+import { ensureLogger, NotFoundError } from "../../../utils.js";
+import { SerdeGateway, SerdeGatewayCtx, SerdeGetResult, UnsubscribeResult, VoidResult } from "../../../blockstore/serde-gateway.js";
+import { registerStoreProtocol } from "../../../blockstore/register-store-protocol.js";
+import { FPEnvelope, FPEnvelopeMeta, FPEnvelopeWAL } from "../../../blockstore/fp-envelope.js";
+import { dbMetaEvent2Serialized, decode2DbMetaEvents, fpDeserialize, fpSerialize } from "../fp-envelope-serialize.js";
+import {
+  BindGetMeta,
+  buildBindGetMeta,
+  buildReqDelMeta,
+  buildReqPutMeta,
+  EventGetMeta,
+  MsgIsEventGetMeta,
+  MsgIsResPutMeta,
+  ReqDelMeta,
+  ReqPutMeta,
+  ResDelMeta,
+  ResPutMeta,
+} from "../../../protocols/cloud/msg-types-meta.js";
+import { encodeAsV2SerializedMetaKey, V2SerializedMetaKeyExtractKey } from "../../meta-key-hack.js";
+
+const VERSION = "v0.1-fp-cloud";
+
+type ConnectedSerdeGatewayCtx = SerdeGatewayCtx & { conn: AuthedConnection };
+
+export interface StoreTypeGateway {
+  get: <S>(ctx: ConnectedSerdeGatewayCtx, url: URI) => Promise<SerdeGetResult<S>>;
+  put: <T>(ctx: ConnectedSerdeGatewayCtx, url: URI, body: FPEnvelope<T>) => Promise<VoidResult>;
+  delete: (ctx: ConnectedSerdeGatewayCtx, url: URI) => Promise<VoidResult>;
+}
+
+abstract class BaseGateway {
+  readonly logger: Logger;
+  readonly sthis: SuperThis;
+  constructor(sthis: SuperThis, module: string) {
+    this.sthis = sthis;
+    this.logger = ensureLogger(sthis, module);
+  }
+
+  async buildReqSignedUrl(
+    type: string,
+    method: HttpMethods,
+    store: FPStoreTypes,
+    uri: URI,
+    conn: AuthedConnection,
+  ): Promise<MsgWithError<ReqSignedUrl>> {
+    const rParams = uri.getParamsResult({
+      key: param.REQUIRED,
+      store: param.REQUIRED,
+      path: param.OPTIONAL,
+      tenant: param.REQUIRED,
+      name: param.REQUIRED,
+      index: param.OPTIONAL,
+    });
+    if (rParams.isErr()) {
+      return buildErrorMsg(this, {} as MsgBase, rParams.Err());
+    }
+    const params = rParams.Ok();
+    if (store !== params.store) {
+      return buildErrorMsg(this, {} as MsgBase, new Error("store mismatch"));
+    }
+    const rAuth = await authTypeFromUri(this.logger, uri);
+    if (rAuth.isErr()) {
+      return buildErrorMsg(this, {} as MsgBase, rAuth.Err());
+    }
+    return {
+      tid: this.sthis.nextId().str,
+      auth: rAuth.Ok(),
+      type,
+      conn: conn.conn.Ok().conn,
+      tenant: {
+        tenant: params.tenant,
+        ledger: params.name,
+      },
+      // tenant: conn.tenant,
+      methodParams: {
+        method,
+        store,
+      },
+      params: {
+        ...params,
+        key: params.key,
+      },
+      version: VERSION,
+    } satisfies ReqSignedUrl;
+  } 
+
+  async getReqSignedUrl<S extends ResSignedUrl>(
+    type: string,
+    method: HttpMethods,
+    store: FPStoreTypes,
+    waitForFn: (msg: MsgBase) => boolean,
+    uri: URI,
+    conn: AuthedConnection,
+  ): Promise<MsgWithError<S>> {
+    const rsu = await this.buildReqSignedUrl(type, method, store, uri, conn);
+    if (MsgIsError(rsu)) {
+      return rsu;
+    }
+    return conn.conn.Ok().request<S, ReqSignedUrl>(rsu, { waitFor: waitForFn });
+  }
+
+  async putObject(uri: URI, uploadUrl: string, body: Uint8Array, conn: AuthedConnection): Promise<Result<void>> {
+    this.logger.Debug().Any("url", { uploadUrl, uri }).Msg("put-fetch-url");
+    const rUpload = await exception2Result(async () => fetch(uploadUrl, { method: "PUT", body }));
+    if (rUpload.isErr()) {
+      return this.logger.Error().Url(uploadUrl, "uploadUrl").Err(rUpload).Msg("Error in put fetch").ResultError();
+    }
+    if (!rUpload.Ok().ok) {
+      return this.logger.Error().Url(uploadUrl, "uploadUrl").Http(rUpload.Ok()).Msg("Error in put fetch").ResultError();
+    }
+    if (uri.getParam("testMode")) {
+      conn.citem.trackPuts.add(uri.toString());
+    }
+    return Result.Ok(undefined);
+  }
+
+  // eslint-disable-next-line @typescript-eslint/no-unused-vars
+  async getObject(uri: URI, downloadUrl: string, _conn: AuthedConnection): Promise<Result<Uint8Array>> {
+    this.logger.Debug().Any("url", { downloadUrl, uri }).Msg("get-fetch-url");
+    const rDownload = await exception2Result(async () => fetch(downloadUrl.toString(), { method: "GET" }));
+    if (rDownload.isErr()) {
+      return this.logger.Error().Url(downloadUrl, "uploadUrl").Err(rDownload).Msg("Error in get downloadUrl").ResultError();
+    }
+    const download = rDownload.Ok();
+    if (!download.ok) {
+      if (download.status === 404) {
+        return Result.Err(new NotFoundError("Not found"));
+      }
+      return this.logger.Error().Url(downloadUrl, "uploadUrl").Err(rDownload).Msg("Error in get fetch").ResultError();
+    }
+    return Result.Ok(to_uint8(await download.arrayBuffer()));
+  }
+
+  // eslint-disable-next-line @typescript-eslint/no-unused-vars
+  async delObject(uri: URI, deleteUrl: string, _conn: AuthedConnection): Promise<Result<void>> {
+    this.logger.Debug().Any("url", { deleteUrl, uri }).Msg("get-fetch-url");
+    const rDelete = await exception2Result(async () => fetch(deleteUrl.toString(), { method: "DELETE" }));
+    if (rDelete.isErr()) {
+      return this.logger.Error().Url(deleteUrl, "deleteUrl").Err(rDelete).Msg("Error in get deleteURL").ResultError();
+    }
+    const download = rDelete.Ok();
+    if (!download.ok) {
+      if (download.status === 404) {
+        return Result.Err(new NotFoundError("Not found"));
+      }
+      return this.logger.Error().Url(deleteUrl, "deleteUrl").Err(rDelete).Msg("Error in del fetch").ResultError();
+    }
+    return Result.Ok(undefined);
+  }
+}
+
+class DataGateway extends BaseGateway implements StoreTypeGateway {
+  constructor(sthis: SuperThis) {
+    super(sthis, "DataGateway");
+  }
+  async get<S>(ctx: ConnectedSerdeGatewayCtx, uri: URI): Promise<SerdeGetResult<S>> {
+    // type: string, method: HttpMethods, store: FPStoreTypes, waitForFn:
+    const store = coerceFPStoreTypes(uri.getParam("store"));
+    const rResSignedUrl = await this.getReqSignedUrl<ResGetData>("reqGetData", "GET", store, MsgIsResGetData, uri, ctx.conn);
+    if (MsgIsError(rResSignedUrl)) {
+      return this.logger.Error().Err(rResSignedUrl).Msg("Error in buildResSignedUrl").ResultError();
+    }
+    const { signedUrl: downloadUrl } = rResSignedUrl;
+    const r = await fpDeserialize(this.sthis, uri, this.getObject(uri, downloadUrl, ctx.conn));
+    return r as SerdeGetResult<S>;
+  }
+  async put<S>(ctx: ConnectedSerdeGatewayCtx, uri: URI, data: FPEnvelope<S>): Promise<Result<void>> {
+    const store = coerceFPStoreTypes(uri.getParam("store"));
+    const rResSignedUrl = await this.getReqSignedUrl<ResPutData>("reqPutData", "PUT", store, MsgIsResPutData, uri, ctx.conn);
+    if (MsgIsError(rResSignedUrl)) {
+      return this.logger.Error().Err(rResSignedUrl).Msg("Error in buildResSignedUrl").ResultError();
+    }
+    const { signedUrl: uploadUrl } = rResSignedUrl;
+    const rBlob = await fpSerialize(ctx.loader.sthis, data);
+    if (rBlob.isErr()) {
+      return rBlob;
+    }
+    const r = await this.putObject(uri, uploadUrl, rBlob.Ok(), ctx.conn);
+    return r
+
+  }
+  async delete(ctx: ConnectedSerdeGatewayCtx, uri: URI): Promise<Result<void>> {
+    const store = coerceFPStoreTypes(uri.getParam("store"));
+    const rResSignedUrl = await this.getReqSignedUrl<ResDelData>("reqDelData", "DELETE", store, MsgIsResDelData, uri, ctx.conn);
+    if (MsgIsError(rResSignedUrl)) {
+      return this.logger.Error().Err(rResSignedUrl).Msg("Error in buildResSignedUrl").ResultError();
+    }
+    const { signedUrl: deleteUrl } = rResSignedUrl;
+    return this.delObject(uri, deleteUrl, ctx.conn);
+  }
+}
+
+function getGwCtx(conn: QSId, uri: URI): Result<GwCtx> {
+  const rParams = uri.getParamsResult({
+    tid: param.OPTIONAL,
+    tenant: param.REQUIRED,
+    ledger: param.REQUIRED,
+  });
+  if (rParams.isErr()) {
+    return Result.Err(rParams);
+  }
+  const r = rParams.Ok();
+  return Result.Ok({
+    tid: r.tid,
+    conn,
+    tenant: {
+      tenant: r.tenant,
+      ledger: r.ledger,
+    },
+  });
+}
+
+class MetaGateway extends BaseGateway implements StoreTypeGateway {
+  constructor(sthis: SuperThis) {
+    super(sthis, "MetaGateway");
+  }
+
+  async get<S>(ctx: ConnectedSerdeGatewayCtx, uri: URI): Promise<SerdeGetResult<S>> {
+    // const sp = sup({ method: "GET", store: "meta" });
+
+    const reqSignedUrl = await this.buildReqSignedUrl("bindGetMeta", "GET", "meta", uri, ctx.conn);
+    if (MsgIsError(reqSignedUrl)) {
+      return this.logger.Error().Err(reqSignedUrl).Msg("Error in buildReqSignedUrl").ResultError();
+    }
+    const rGwCtx = getGwCtx(ctx.conn.conn.Ok().conn, uri);
+    if (rGwCtx.isErr()) {
+      return Result.Err(rGwCtx);
+    }
+    const rAuthType = await ctx.conn.conn.Ok().authType();
+    if (rAuthType.isErr()) {
+      return Result.Err(rAuthType);
+    }
+    const res = await ctx.conn.conn
+      .Ok()
+      .request<EventGetMeta, BindGetMeta>(buildBindGetMeta(ctx.loader.sthis, rAuthType.Ok(), reqSignedUrl.params, rGwCtx.Ok()), {
+        waitFor: MsgIsEventGetMeta,
+      });
+    if (MsgIsError(res)) {
+      return this.logger.Error().Err(res).Msg("Error in buildBindGetMeta").ResultError();
+    }
+    const rV2Meta = await V2SerializedMetaKeyExtractKey(ctx, res.meta);
+    const rMeta = await decode2DbMetaEvents(ctx.loader.sthis, rV2Meta);
+    if (rMeta.isErr()) {
+      return Result.Err(rMeta);
+    }
+    return Result.Ok({
+      type: "meta",
+      payload: rMeta.Ok(),
+    } satisfies FPEnvelopeMeta as FPEnvelope<S>);
+  }
+  async put<S>(ctx: ConnectedSerdeGatewayCtx, uri: URI, imeta: FPEnvelope<S>): Promise<Result<void>> {
+    const meta = imeta as FPEnvelopeMeta;
+    const reqSignedUrl = await this.buildReqSignedUrl("reqPutMeta", "PUT", "meta", uri, ctx.conn);
+    if (MsgIsError(reqSignedUrl)) {
+      return this.logger.Error().Err(reqSignedUrl).Msg("Error in buildReqSignedUrl").ResultError();
+    }
+    const rGwCtx = getGwCtx(ctx.conn.conn.Ok().conn, uri);
+    if (rGwCtx.isErr()) {
+      return Result.Err(rGwCtx);
+    }
+    const rAuthType = await ctx.conn.conn.Ok().authType();
+    if (rAuthType.isErr()) {
+      return Result.Err(rAuthType);
+    }
+
+    const serializedMeta = await dbMetaEvent2Serialized(ctx.loader.sthis, meta.payload);
+
+    const rKeyedMeta = await encodeAsV2SerializedMetaKey(ctx, serializedMeta);
+    if (rKeyedMeta.isErr()) {
+      return rKeyedMeta;
+    }
+    const reqPutMeta = buildReqPutMeta(ctx.loader.sthis, rAuthType.Ok(), reqSignedUrl.params, rKeyedMeta.Ok(), rGwCtx.Ok());
+    const resMsg = await ctx.conn.conn.Ok().request<ResPutMeta, ReqPutMeta>(reqPutMeta, {
+      waitFor: MsgIsResPutMeta,
+    });
+    if (MsgIsError(resMsg)) {
+      return this.logger.Error().Err(resMsg).Msg("Error in buildResSignedUrl").ResultError();
+    }
+    return Result.Ok(undefined);
+  }
+
+  async delete(ctx: ConnectedSerdeGatewayCtx, uri: URI): Promise<Result<void>> {
+    const reqSignedUrl = await this.getReqSignedUrl<ResDelData>("reqDelMeta", "DELETE", "meta", MsgIsResDelData, uri, ctx.conn);
+    if (MsgIsError(reqSignedUrl)) {
+      return this.logger.Error().Err(reqSignedUrl).Msg("Error in buildReqSignedUrl").ResultError();
+    }
+    const rGwCtx = getGwCtx(ctx.conn.conn.Ok().conn, uri);
+    if (rGwCtx.isErr()) {
+      return Result.Err(rGwCtx);
+    }
+    const rAuthType = await ctx.conn.conn.Ok().authType();
+    if (rAuthType.isErr()) {
+      return Result.Err(rAuthType);
+    }
+    const reqDelMeta = buildReqDelMeta(ctx.loader.sthis, rAuthType.Ok(), reqSignedUrl.params, rGwCtx.Ok());
+    const resMsg = await ctx.conn.conn.Ok().request<ResDelMeta, ReqDelMeta>(reqDelMeta, {
+      waitFor: MsgIsResDelData,
+    });
+    if (MsgIsError(resMsg)) {
+      return this.logger.Error().Err(resMsg).Msg("Error in buildResSignedUrl").ResultError();
+    }
+    return Result.Ok(undefined);
+  }
+}
+
+class WALGateway extends BaseGateway implements StoreTypeGateway {
+  // WAL will not pollute to the cloud
+  readonly wals = new Map<string, FPEnvelopeWAL>();
+  constructor(sthis: SuperThis) {
+    super(sthis, "WALGateway");
+  }
+  getWalKeyFromUri(uri: URI): Result<string> {
+    const rKey = uri.getParamsResult({
+      key: 0,
+      name: 0,
+    });
+    if (rKey.isErr()) {
+      return Result.Err(rKey.Err());
+    }
+    const { name, key } = rKey.Ok();
+    return Result.Ok(`${name}:${key}`);
+  }
+  async get<S>(ctx: ConnectedSerdeGatewayCtx, uri: URI): Promise<SerdeGetResult<S>> {
+    const rKey = this.getWalKeyFromUri(uri);
+    if (rKey.isErr()) {
+      return Result.Err(rKey.Err());
+    }
+    const wal = this.wals.get(rKey.Ok());
+    if (!wal) {
+      return Result.Err(new NotFoundError("Not found"));
+    }
+    return Result.Ok(wal as FPEnvelope<S>);
+  }
+  async put<S>(ctx: ConnectedSerdeGatewayCtx, uri: URI, body: FPEnvelope<S>): Promise<Result<void>> {
+    const rKey = this.getWalKeyFromUri(uri);
+    if (rKey.isErr()) {
+      return Result.Err(rKey.Err());
+    }
+    this.wals.set(rKey.Ok(), body as FPEnvelopeWAL);
+    return Result.Ok(undefined);
+  }
+  async delete(ctx: ConnectedSerdeGatewayCtx, uri: URI): Promise<Result<void>> {
+    const rKey = this.getWalKeyFromUri(uri);
+    if (rKey.isErr()) {
+      return Result.Err(rKey.Err());
+    }
+    this.wals.delete(rKey.Ok());
+    return Result.Ok(undefined);
+  }
+}
+
+const storeTypedGateways = new KeyedResolvOnce<StoreTypeGateway>();
+function getStoreTypeGateway(sthis: SuperThis, uri: URI): StoreTypeGateway {
+  const store = uri.getParam("store");
+  switch (store) {
+    case "file":
+    case "car":
+      return storeTypedGateways.get(store).once(() => new DataGateway(sthis));
+    case "meta":
+      return storeTypedGateways.get(store).once(() => new MetaGateway(sthis));
+    case "wal":
+      return storeTypedGateways.get(store).once(() => new WALGateway(sthis));
+    default:
+      throw ensureLogger(sthis, "getStoreTypeGateway").Error().Str("store", store).Msg("Invalid store type").ResultError();
+  }
+}
+
+interface ConnectionItem {
+  readonly uri: URI;
+  readonly matchRes: MatchResult;
+  readonly connection: ResolveOnce<Result<MsgConnected>>;
+  readonly trackPuts: Set<string>;
+}
+
+interface AuthedConnection {
+  readonly conn: Result<MsgConnectedAuth>;
+  readonly citem: ConnectionItem;
+}
+
+// const keyedConnections = new KeyedResolvOnce<Connection>();
+interface Subscription {
+  readonly sid: string;
+  readonly uri: string; // optimization
+  readonly callback: (msg: Uint8Array) => void;
+  readonly unsub: () => void;
+}
+function connectionURI(uri: URI): URI {
+  return uri.build().delParam("authJWK").delParam("key").delParam("store").delParam("suffix").delParam("storekey").URI();
+}
+
+const subscriptions = new Map<string, Subscription[]>();
+// const doServerSubscribe = new KeyedResolvOnce();
+export class FireproofCloudGateway implements SerdeGateway {
+  readonly logger: Logger;
+  readonly sthis: SuperThis;
+  readonly #connectionURIs = new Map<string, ConnectionItem>();
+
+  constructor(sthis: SuperThis) {
+    this.sthis = sthis;
+    this.logger = ensureLogger(sthis, "FireproofCloudGateway", {
+      this: true,
+    });
+    // console.log("FireproofCloudGateway", this.sthis.nextId().str);
+  }
+
+  async buildUrl(ctx: SerdeGatewayCtx, baseUrl: URI, key: string): Promise<Result<URI>> {
+    return Result.Ok(baseUrl.build().setParam("key", key).URI());
+  }
+
+  async start(ctx: SerdeGatewayCtx, uri: URI): Promise<Result<URI>> {
+    await this.sthis.start();
+    const rName = uri.getParamResult("name");
+    if (rName.isErr()) {
+      return this.logger.Error().Err(rName).Msg("name not found").ResultError();
+    }
+    const ret = uri.build().defParam("version", VERSION);
+    ret.defParam("protocol", "wss");
+    const retURI = ret.URI();
+    const matchURI = connectionURI(retURI);
+    // console.log("start", matchURI.toString());
+    this.#connectionURIs.set(matchURI.toString(), {
+      uri: matchURI,
+      matchRes: matchURI.match(matchURI),
+      connection: new ResolveOnce<Result<MsgConnected>>(),
+      trackPuts: new Set<string>(),
+    });
+    return Result.Ok(retURI);
+  }
+
+  async get<S>(ctx: SerdeGatewayCtx, uri: URI): Promise<SerdeGetResult<S>> {
+    const conn = await this.getCloudConnectionItem(uri);
+    if (conn.conn.isErr()) {
+      return Result.Err(conn.conn);
+    }
+    const ret = await getStoreTypeGateway(ctx.loader.sthis, uri).get<S>({ ...ctx, conn }, uri);
+    // console.log("get>>>>>>>>>>>>>", conn.conn.Ok().conn, uri.toString(), ret);
+    return ret;
+  }
+
+  async put<T>(ctx: SerdeGatewayCtx, uri: URI, body: FPEnvelope<T>): Promise<VoidResult> {
+    const conn = await this.getCloudConnectionItem(uri);
+    if (conn.conn.isErr()) {
+      // console.log("put-conn-err", conn.conn);
+      return conn.conn;
+    }
+    const ret = await getStoreTypeGateway(ctx.loader.sthis, uri).put<T>({ ...ctx, conn }, uri, body);
+    // console.log("put-conn-r", ret.isOk());
+    if (ret.isOk()) {
+      if (uri.getParam("testMode")) {
+        conn.citem.trackPuts.add(uri.toString());
+      }
+    }
+    return ret;
+  }
+
+  async delete(ctx: SerdeGatewayCtx, uri: URI): Promise<VoidResult> {
+    const conn = await this.getCloudConnectionItem(uri);
+    if (conn.conn.isErr()) {
+      return conn.conn;
+    }
+    conn.citem.trackPuts.delete(uri.toString());
+    return getStoreTypeGateway(ctx.loader.sthis, uri).delete({ ...ctx, conn }, uri);
+  }
+
+  async close(ctx: SerdeGatewayCtx, uri: URI): Promise<VoidResult> {
+    const uriStr = uri.toString();
+    // CAUTION here is my happen a mutation of subscriptions caused by unsub
+    for (const sub of Array.from(subscriptions.values())) {
+      for (const s of sub) {
+        if (s.uri.toString() === uriStr) {
+          s.unsub();
+        }
+      }
+    }
+    const rConn = await this.getCloudConnectionItem(uri);
+    if (rConn.conn.isErr()) {
+      return this.logger.Error().Err(rConn).Msg("Error in getCloudConnection").ResultError();
+    }
+    const conn = rConn.conn.Ok();
+    const rAuth = await conn.msgConnAuth();
+    await conn.close(rAuth.Ok());
+    this.#connectionURIs.delete(rConn.citem.uri.toString());
+    return Result.Ok(undefined);
+  }
+
+  // fireproof://localhost:1999/?name=test-public-api&protocol=ws&store=meta
+  async getCloudConnection(uri: URI): Promise<Result<MsgConnectedAuth>> {
+    return this.getCloudConnectionItem(uri).then((r) => {
+      return r.conn;
+    });
+  }
+
+  async getCloudConnectionItem(uri: URI): Promise<AuthedConnection> {
+    const matchURI = connectionURI(uri);
+    let bestMatch: ConnectionItem | undefined;
+    for (const ci of this.#connectionURIs.values()) {
+      const mci = ci.uri.match(matchURI);
+      if (mci.score >= ci.matchRes.score) {
+        bestMatch = ci;
+        break;
+      }
+    }
+    if (!bestMatch) {
+      return {
+        conn: this.logger.Error().Url(matchURI).Any("conns", Object.fromEntries(this.#connectionURIs.entries())).Msg("No connection found").ResultError(),
+        citem: {} as ConnectionItem,
+      };
+    }
+    const conn = await bestMatch.connection.once(async () => {
+      const rParams = uri.getParamsResult({
+        name: param.REQUIRED,
+        protocol: "https",
+        store: param.REQUIRED,
+        storekey: param.OPTIONAL,
+        tenant: param.REQUIRED,
+      });
+      if (rParams.isErr()) {
+        return this.logger.Error().Url(uri).Err(rParams).Msg("getCloudConnection:err").ResultError<MsgConnected>();
+      }
+      const params = rParams.Ok();
+      // let tenant: string;
+      // if (params.tenant) {
+      //   tenant = params.tenant;
+      // } else {
+      //   if (!params.storekey) {
+      //     return this.logger.Error().Url(uri).Msg("no tendant or storekey given").ResultError();
+      //   }
+      //   const dataKey = params.storekey.replace(/:(meta|wal)@$/, `:data@`);
+      //   const kb = await rt.kb.getKeyBag(this.sthis);
+      //   const rfingerprint = await kb.getNamedKey(dataKey);
+      //   if (rfingerprint.isErr()) {
+      //     return this.logger.Error().Err(rfingerprint).Msg("Error in getNamedKey").ResultError();
+      //   }
+      //   tenant = rfingerprint.Ok().fingerPrint;
+      // }
+
+      const rAuth = await authTypeFromUri(this.logger, uri);
+      if (rAuth.isErr()) {
+        return Result.Err<MsgConnected>(rAuth);
+      }
+
+      const qOpen = buildReqOpen(this.sthis, rAuth.Ok(), {});
+
+      const cUrl = uri.build().protocol(params.protocol).cleanParams().URI();
+      // if (cUrl.pathname === "/") {
+      //   cUrl = cUrl.build().pathname("/fp").URI();
+      // }
+      return Msger.connect(this.sthis, rAuth.Ok(), cUrl, qOpen);
+    });
+    if (conn.isErr()) {
+      return { conn: Result.Err(conn), citem: bestMatch };
+    }
+    return { conn: Result.Ok(conn.Ok().attachAuth(() => authTypeFromUri(this.logger, uri))), citem: bestMatch };
+    //  keyedConnections.get(keyTenantLedger(qOpen.conn.key)).once(async () => Msger.open(this.sthis, cUrl, qOpen));
+  }
+
+  // private notifySubscribers(data: Uint8Array, callbacks: ((msg: Uint8Array) => void)[] = []): void {
+  //   for (const cb of callbacks) {
+  //     try {
+  //       cb(data);
+  //     } catch (error) {
+  //       this.logger.Error().Err(error).Msg("Error in subscriber callback execution");
+  //     }
+  //   }
+  // }
+  // eslint-disable-next-line @typescript-eslint/no-unused-vars
+  async subscribe(ctx: SerdeGatewayCtx, url: URI, callback: (meta: FPEnvelopeMeta) => Promise<void>): Promise<UnsubscribeResult> {
+    return Result.Err(new Error("Not implemented"));
+    // const rParams = uri.getParamsResult({
+    //   store: 0,
+    //   storekey: 0,
+    // });
+    // if (rParams.isErr()) {
+    //   return this.logger.Error().Err(rParams).Msg("Error in subscribe").ResultError();
+    // }
+    // const { store } = rParams.Ok();
+    // if (store !== "meta") {
+    //   return Result.Err(new Error("store must be meta"));
+    // }
+    // const rConn = await this.getCloudConnection(uri);
+    // if (rConn.isErr()) {
+    //   return this.logger.Error().Err(rConn).Msg("Error in subscribe:getCloudConnection").ResultError();
+    // }
+    // const conn = rConn.Ok();
+    // const rResSubscribeMeta = await doServerSubscribe.get(pkKey(conn.key)).once(async () => {
+    //   const subId = this.sthis.nextId().str;
+    //   const fn = (subId: string) => (msg: MsgBase) => {
+    //     if (MsgIsUpdateMetaEvent(msg) && subId === msg.subscriberId) {
+    //       // console.log("onMessage", subId, conn.key, msg.metas);
+    //       const s = subscriptions.get(subId);
+    //       if (!s) {
+    //         return;
+    //       }
+    //       console.log("msg", JSON.stringify(msg));
+    //       this.notifySubscribers(
+    //         this.sthis.txt.encode(JSON.stringify(msg.metas)),
+    //         s.map((s) => s.callback)
+    //       );
+    //     }
+    //   };
+    //   conn.onMessage(fn(subId));
+    //   return conn.request<ResSubscribeMeta>(buildReqSubscriptMeta(this.sthis, conn.key, subId), {
+    //     waitType: "resSubscribeMeta",
+    //   });
+    // });
+    // if (rResSubscribeMeta.isErr()) {
+    //   return this.logger.Error().Err(rResSubscribeMeta).Msg("Error in subscribe:request").ResultError();
+    // }
+    // const subId = rResSubscribeMeta.Ok().subscriberId;
+    // let callbacks = subscriptions.get(subId);
+    // if (!callbacks) {
+    //   callbacks = [];
+    //   subscriptions.set(subId, callbacks);
+    // }
+    // const sid = this.sthis.nextId().str;
+    // const unsub = () => {
+    //   const idx = callbacks.findIndex((c) => c.sid === sid);
+    //   if (idx !== -1) {
+    //     callbacks.splice(idx, 1);
+    //   }
+    //   if (callbacks.length === 0) {
+    //     subscriptions.delete(subId);
+    //   }
+    // };
+    // callbacks.push({ uri: uri.toString(), callback, sid, unsub });
+    // return Result.Ok(unsub);
+  }
+
+  async destroy(ctx: SerdeGatewayCtx, uri: URI): Promise<VoidResult> {
+    const item = await this.getCloudConnectionItem(uri);
+    if (item.conn.isErr()) {
+      return item.conn;
+    }
+    await Promise.all(Array.from(item.citem.trackPuts).map(async (k) => this.delete(ctx, URI.from(k))));
+    return Result.Ok(undefined);
+  }
+
+  async getPlain(): Promise<Result<Uint8Array>> {
+    return Result.Err(new Error("Not implemented"));
+    // const url = uri.build().setParam("key", key).URI();
+    // const dbFile = this.sthis.pathOps.join(rt.getPath(url, this.sthis), rt.getFileName(url, this.sthis));
+    // this.logger.Debug().Url(url).Str("dbFile", dbFile).Msg("get");
+    // const buffer = await this.gateway.get(url);
+    // this.logger.Debug().Url(url).Str("dbFile", dbFile).Len(buffer).Msg("got");
+    // return buffer.Ok();
+  }
+}
+
+const onceRegisterFireproofCloudStoreProtocol = new KeyedResolvOnce<() => void>();
+export function registerFireproofCloudStoreProtocol(protocol = "fpcloud:") {
+  return onceRegisterFireproofCloudStoreProtocol.get(protocol).once(() => {
+    URI.protocolHasHostpart(protocol);
+    return registerStoreProtocol({
+      protocol,
+      defaultURI() {
+        return URI.from("fpcloud://fireproof.cloud/");
+      },
+      serdegateway: async (sthis: SuperThis) => {
+        return new FireproofCloudGateway(sthis);
+      },
+    });
+  });
+}
+
+registerFireproofCloudStoreProtocol();
+
+export function toCloud(url: CoerceURI): Attachable {
+  const urlObj = URI.from(url);
+  if (urlObj.protocol !== "fpcloud:") {
+    throw new Error("url must have fireproof protocol");
+  }
+  // const existingName = urlObj.getParam("name");
+  // urlObj.defParam("name", remoteDbName || existingName || dbName);
+  // urlObj.defParam("localName", dbName);
+  // urlObj.defParam("storekey", `@${dbName}:data@`);
+  return {
+    name: urlObj.protocol,
+    prepare(): Promise<GatewayUrlsParam> {
+      return Promise.resolve({
+        car: { url: urlObj },
+        file: { url: urlObj },
+        meta: { url: urlObj },
+      });
+    },
+  };
+}
+++ b/src/runtime/gateways/index.ts
+export * as cloud from "./cloud/gateway.js";
+++ b/src/runtime/index.ts
+export * as sts from "./sts-service/index.js";
+
+export * from "./meta-key-hack.js";
+
+++ b/src/runtime/meta-key-hack.ts
+import { exception2Result, Result, URI } from "@adviser/cement";
+import { SerializedMeta } from "./gateways/fp-envelope-serialize.js";
+import { SerdeGateway, SerdeGatewayCtx } from "../blockstore/serde-gateway.js";
+import { PARAM, SuperThis } from "../types.js";
+import { FPEnvelope, FPEnvelopeMeta } from "../blockstore/fp-envelope.js";
+import { NotFoundError } from "../utils.js";
+import { DefSerdeGateway } from "./gateways/def-serde-gateway.js";
+import { Gateway } from "../blockstore/gateway.js";
+import { Loadable } from "../blockstore/types.js";
+
+type V1SerializedMetaKey = SerializedMeta & {
+  // old version
+  readonly key?: string | string[];
+  // new version
+  readonly keys?: string[];
+};
+
+export interface V2SerializedMetaKey {
+  readonly metas: SerializedMeta[];
+  readonly keys: string[];
+}
+
+// type SerializedMetaWithKey = V1SerializedMetaKey[] | V2SerializedMetaKey;
+
+function fromV1toV2SerializedMetaKey(v1s: unknown[], keys: string[] = []): V2SerializedMetaKey {
+  const res = (v1s as Partial<V1SerializedMetaKey>[]).reduce(
+    (acc, v1) => {
+      const keys: string[] = [];
+      if (v1.key) {
+        if (typeof v1.key === "string") {
+          acc.keys.add(v1.key);
+        } else {
+          keys.push(...v1.key);
+        }
+      }
+      if (v1.keys) {
+        keys.push(...v1.keys);
+      }
+      for (const key of keys) {
+        acc.keys.add(key);
+      }
+      if (typeof v1.cid === "string" && (!v1.data || typeof v1.data === "string") && (!v1.parents || Array.isArray(v1.parents))) {
+        acc.metas.set(v1.cid, {
+          data: v1.data ?? "",
+          parents: v1.parents ?? [],
+          cid: v1.cid,
+        });
+      }
+      return acc;
+    },
+    {
+      metas: new Map<string, SerializedMeta>(),
+      keys: new Set<string>(keys),
+    },
+  );
+  return {
+    metas: Array.from(res.metas.values()),
+    keys: Array.from(res.keys),
+  };
+}
+
+function isV2SerializedMetaKey(or: NonNullable<unknown>): or is Partial<V2SerializedMetaKey> {
+  const my = or as Partial<V2SerializedMetaKey>;
+  return my !== null && (!my.keys || Array.isArray(my.keys)) && (!my.metas || Array.isArray(my.metas));
+}
+
+function toV2SerializedMetaKey(or: NonNullable<unknown>): V2SerializedMetaKey {
+  if (Array.isArray(or)) {
+    return fromV1toV2SerializedMetaKey(or);
+  }
+  if (isV2SerializedMetaKey(or)) {
+    return fromV1toV2SerializedMetaKey(or.metas ?? [], or.keys ?? []);
+  }
+  throw new Error("not a valid serialized meta key");
+}
+
+export async function V2SerializedMetaKeyExtractKey(
+  ctx: SerdeGatewayCtx,
+  v2: V2SerializedMetaKey,
+): Promise<Result<SerializedMeta[]>> {
+  const kb = await ctx.loader.keyBag();
+  if (!kb) {
+    return Promise.resolve(Result.Err(new Error("missing keybag")));
+  }
+  const dataUrl = await ctx.loader.attachedStores.local().active.car.url();
+  const keyName = dataUrl.getParam(PARAM.STORE_KEY);
+  if (!keyName) {
+    ctx.loader.sthis.logger.Warn().Url(dataUrl).Msg("missing store key");
+  } else {
+    const rKey = await kb.getNamedKey(keyName);
+    if (rKey.isErr()) {
+      ctx.loader.sthis.logger.Warn().Str("keyName", keyName).Msg("did not found a extractable key");
+    } else {
+      for (const keyStr of v2.keys) {
+        // side effect: in the keybag
+        // this is the key gossip protocol
+        // it basically collects all the keys that are used distributed metas
+        const res = await rKey.Ok().upsert(keyStr, false);
+        if (res.isErr()) {
+          ctx.loader.sthis.logger.Warn().Str("keyStr", keyStr).Msg("failed to upsert key");
+        }
+      }
+    }
+  }
+  return Promise.resolve(Result.Ok(v2.metas));
+}
+
+export async function decodeAsToSerializedMeta(ctx: SerdeGatewayCtx, raw: Uint8Array): Promise<Result<V2SerializedMetaKey>> {
+  const rJsObj = exception2Result(() => JSON.parse(ctx.loader.sthis.txt.decode(raw))) as Result<NonNullable<unknown>>;
+  if (rJsObj.isErr()) {
+    return Result.Err(rJsObj);
+  }
+  const v2 = toV2SerializedMetaKey(rJsObj.unwrap());
+  const metas = await V2SerializedMetaKeyExtractKey(ctx, v2);
+  if (metas.isErr()) {
+    return Result.Err(metas);
+  }
+  return Result.Ok({
+    metas: metas.Ok(),
+    keys: v2.keys,
+  });
+}
+
+export function addKeyToDbMetaDecoder(
+  ctx: SerdeGatewayCtx & { readonly lastDecodedMetas?: V2SerializedMetaKey[] },
+): SerdeGatewayCtx & { lastDecodedMetas: V2SerializedMetaKey[] } {
+  const lastDecodedMetas: V2SerializedMetaKey[] = ctx.lastDecodedMetas ?? [];
+  return {
+    ...ctx,
+    lastDecodedMetas,
+    decoder: {
+      meta: async (sthis: SuperThis, raw: Uint8Array): Promise<Result<SerializedMeta[]>> => {
+        const r = await decodeAsToSerializedMeta(ctx, raw);
+        if (r.isErr()) {
+          return Promise.resolve(Result.Err(r));
+        }
+        // we only want to keep the last 2 metas
+        if (lastDecodedMetas.length > 2) {
+          lastDecodedMetas.shift();
+        }
+        lastDecodedMetas.push(r.Ok());
+        return Promise.resolve(Result.Ok(r.Ok().metas));
+      },
+    },
+  };
+}
+
+async function wrapEncode<T extends V1SerializedMetaKey[] | V2SerializedMetaKey>(
+  ctx: SerdeGatewayCtx,
+  payload: SerializedMeta[],
+  fn: (payload: SerializedMeta[], keyM: string[]) => T,
+): Promise<Result<T>> {
+  const carStore = ctx.loader.attachedStores.local().active.car;
+  const kb = await ctx.loader.keyBag();
+  if (!kb) {
+    return Promise.resolve(Result.Err(new Error("missing keybag")));
+  }
+  const keyName = carStore.url().getParam(PARAM.STORE_KEY) ?? "";
+  const rKex = await kb.getNamedKey(keyName);
+  if (rKex.isErr()) {
+    return Promise.resolve(Result.Err(rKex.Err()));
+  }
+  /* security: we don't want to log the key */
+  const keyMaterials = await rKex
+    .Ok()
+    .asKeysItem()
+    .then((i) => Object.values(i.keys).map((i) => i.key));
+
+  return Promise.resolve(Result.Ok(fn(payload, keyMaterials)));
+}
+
+export function encodeAsV1SerializedMetaKey(
+  ctx: SerdeGatewayCtx,
+  payload: SerializedMeta[],
+): Promise<Result<V1SerializedMetaKey[]>> {
+  return wrapEncode(ctx, payload, (payload, keyM) => payload.map((p) => ({ ...p, key: keyM }) satisfies V1SerializedMetaKey));
+}
+
+export function encodeAsV2SerializedMetaKey(ctx: SerdeGatewayCtx, payload: SerializedMeta[]): Promise<Result<V2SerializedMetaKey>> {
+  return wrapEncode(
+    ctx,
+    payload,
+    (payload, keyM) =>
+      ({
+        metas: payload,
+        keys: keyM,
+      }) satisfies V2SerializedMetaKey,
+  );
+}
+
+export function addKeyToDbMetaEncoder(ctx: SerdeGatewayCtx, version: "v1" | "v2"): SerdeGatewayCtx {
+  return {
+    ...ctx,
+    encoder: {
+      meta: async (sthis: SuperThis, payload: SerializedMeta[]): Promise<Result<Uint8Array>> => {
+        let obj: Result<V1SerializedMetaKey[] | V2SerializedMetaKey>;
+        switch (version) {
+          case "v1":
+            obj = await encodeAsV1SerializedMetaKey(ctx, payload);
+            break;
+          case "v2":
+            obj = await encodeAsV2SerializedMetaKey(ctx, payload);
+            break;
+          default:
+            return Promise.resolve(Result.Err(`unknown version:[${version}]`));
+        }
+        if (obj.isErr()) {
+          return Promise.resolve(Result.Err(obj));
+        }
+        try {
+          return Promise.resolve(Result.Ok(sthis.txt.encode(JSON.stringify(obj.Ok()))));
+        } catch (e) {
+          return Promise.resolve(Result.Err(e as Error));
+        }
+      },
+    },
+  };
+}
+
+export class AddKeyToDbMetaGateway implements SerdeGateway {
+  private readonly sdGw: DefSerdeGateway;
+  readonly version: "v1" | "v2";
+  constructor(gw: Gateway, version: "v1" | "v2") {
+    this.sdGw = new DefSerdeGateway(gw);
+    this.version = version;
+  }
+
+  buildUrl(ctx: SerdeGatewayCtx, baseUrl: URI, key: string): Promise<Result<URI>> {
+    return this.sdGw.buildUrl(ctx, baseUrl, key);
+  }
+  start(ctx: SerdeGatewayCtx, baseUrl: URI): Promise<Result<URI>> {
+    return this.sdGw.start(ctx, baseUrl);
+  }
+  close(ctx: SerdeGatewayCtx, baseUrl: URI): Promise<Result<void, Error>> {
+    return this.sdGw.close(ctx, baseUrl);
+  }
+  async put<T>(ctx: SerdeGatewayCtx, url: URI, body: FPEnvelope<T>): Promise<Result<void, Error>> {
+    return this.sdGw.put(addKeyToDbMetaEncoder(ctx, this.version), url, body);
+  }
+  async get<S>(ctx: SerdeGatewayCtx, url: URI): Promise<Result<FPEnvelope<S>, Error | NotFoundError>> {
+    return this.sdGw.get(addKeyToDbMetaDecoder({ ...ctx, lastDecodedMetas: this.lastDecodedMetas }), url);
+  }
+
+  // only for tests
+  readonly lastDecodedMetas: V2SerializedMetaKey[] = [];
+
+  // eslint-disable-next-line @typescript-eslint/no-unused-vars
+  delete(ctx: SerdeGatewayCtx, url: URI, loader?: Loadable): Promise<Result<void, Error>> {
+    return this.sdGw.delete(ctx, url);
+  }
+  subscribe(ctx: SerdeGatewayCtx, url: URI, callback: (meta: FPEnvelopeMeta) => Promise<void>): Promise<Result<() => void, Error>> {
+    return this.sdGw.subscribe(addKeyToDbMetaDecoder({ ...ctx, lastDecodedMetas: this.lastDecodedMetas }), url, callback);
+  }
+  getPlain(ctx: SerdeGatewayCtx, url: URI, key: string): Promise<Result<Uint8Array>> {
+    return this.sdGw.getPlain(ctx, url, key);
+  }
+  destroy(ctx: SerdeGatewayCtx, baseUrl: URI): Promise<Result<void, Error>> {
+    return this.sdGw.destroy(ctx, baseUrl);
+  }
+}
+++ b/src/runtime/sts-service/index.ts
+import { Result, exception2Result } from "@adviser/cement";
+import { exportJWK, importJWK, JWTVerifyResult, jwtVerify, SignJWT } from "jose";
+import { generateKeyPair, GenerateKeyPairOptions } from "jose/key/generate/keypair";
+import { base58btc } from "multiformats/bases/base58";
+import { ensureSuperThis } from "../../utils.js";
+import { SuperThis } from "../../types.js";
+import { BaseTokenParam, FPCloudClaim, TokenForParam } from "../../protocols/cloud/msg-types.js";
+
+export const envKeyDefaults = {
+  SECRET: "CLOUD_SESSION_TOKEN_SECRET",
+  PUBLIC: "CLOUD_SESSION_TOKEN_PUBLIC",
+};
+
+interface SessionTokenServiceParam extends Partial<BaseTokenParam> {
+  readonly token: string; // env encoded jwk
+}
+
+interface SessionTokenServiceFromEnvParam extends Partial<BaseTokenParam> {
+  readonly privateEnvKey?: string; // defaults CLOUD_SESSION_TOKEN_SECRET
+  readonly publicEnvKey?: string; // defaults CLOUD_SESSION_TOKEN_PUBLIC
+}
+
+export async function jwk2env(jwk: CryptoKey, sthis = ensureSuperThis()): Promise<string> {
+  const inPubKey = await exportJWK(jwk);
+  return base58btc.encode(sthis.txt.encode(JSON.stringify(inPubKey)));
+}
+
+export async function env2jwk(env: string, alg: string, sthis = ensureSuperThis()): Promise<CryptoKey> {
+  const inJWT = JSON.parse(sthis.txt.decode(base58btc.decode(env)));
+  return importJWK(inJWT, alg, { extractable: true }) as Promise<CryptoKey>;
+}
+
+export interface KeysResult {
+  readonly material: CryptoKeyPair;
+  readonly strings: { readonly publicKey: string; readonly privateKey: string };
+}
+
+export class SessionTokenService {
+  readonly #key: CryptoKey;
+  readonly #param: SessionTokenServiceParam;
+
+  static async generateKeyPair(
+    alg = "ES256",
+    options: GenerateKeyPairOptions = { extractable: true },
+    generateKeyPairFN = (alg: string, options: GenerateKeyPairOptions) => generateKeyPair(alg, options),
+  ): Promise<KeysResult> {
+    const material = await generateKeyPairFN(alg, options);
+    return {
+      material,
+      strings: {
+        publicKey: await jwk2env(material.publicKey),
+        privateKey: await jwk2env(material.privateKey),
+      },
+    };
+  }
+
+  static async createFromEnv(sp: SessionTokenServiceFromEnvParam = {}, sthis: SuperThis = ensureSuperThis()) {
+    let envToken = sthis.env.get(sp.privateEnvKey ?? envKeyDefaults.SECRET);
+    if (!envToken) {
+      envToken = sthis.env.get(sp.publicEnvKey ?? envKeyDefaults.PUBLIC);
+    }
+    if (!envToken) {
+      throw new Error(
+        `env not found for: ${sp.privateEnvKey ?? envKeyDefaults.SECRET} or ${sp.publicEnvKey ?? envKeyDefaults.PUBLIC}`,
+      );
+    }
+    return SessionTokenService.create({ token: envToken }, sthis);
+  }
+
+  static async create(stsparam: SessionTokenServiceParam, sthis: SuperThis = ensureSuperThis()) {
+    const key = await env2jwk(stsparam.token, stsparam.alg ?? "ES256", sthis);
+    return new SessionTokenService(key, stsparam);
+  }
+
+  private constructor(key: CryptoKey, stsparam: SessionTokenServiceParam) {
+    this.#key = key;
+    this.#param = stsparam;
+  }
+
+  get validFor() {
+    let validFor = this.#param.validFor ?? 3600;
+    if (!(0 <= validFor && validFor <= 3600000)) {
+      validFor = 3600000;
+    }
+    return validFor;
+  }
+
+  get alg() {
+    return this.#param.alg ?? "ES256";
+  }
+
+  get isssuer() {
+    return this.#param.issuer ?? "fireproof";
+  }
+
+  get audience() {
+    return this.#param.audience ?? "fireproof";
+  }
+
+  async validate(token: string): Promise<Result<JWTVerifyResult<FPCloudClaim>>> {
+    return exception2Result(async () => {
+      const ret = await jwtVerify<FPCloudClaim>(token, this.#key);
+      return ret;
+    });
+  }
+
+  // async getEnvKey(): Promise<string> {
+  //   return jwk2env(ensureSuperThis(), this.#key);
+  // }
+
+  async tokenFor(p: TokenForParam): Promise<string> {
+    if (this.#key.type !== "private") {
+      throw new Error("key must be private");
+    }
+    const token = await new SignJWT({
+      userId: p.userId,
+      tenants: p.tenants,
+      ledgers: p.ledgers,
+    } satisfies FPCloudClaim)
+      .setProtectedHeader({ alg: this.alg }) // algorithm
+      .setIssuedAt()
+      .setIssuer(p.issuer ?? this.isssuer) // issuer
+      .setAudience(p.audience ?? this.audience) // audience
+      .setExpirationTime(Date.now() + (p.validFor ?? this.validFor)) // expiration time
+      .sign(this.#key);
+    return token;
+  }
+}
+++ b/src/types.ts
+export type Unreg = () => void;
+
+++ b/tests/runtime/meta-key-hack.test.ts
+import { URI } from "@adviser/cement";
+import { rt, bs, fireproof, PARAM, ensureSuperThis, Database } from "@fireproof/core";
+
+describe("MetaKeyHack", () => {
+  const storageMap = new Map();
+
+  const sthis = ensureSuperThis();
+  const memGw = new rt.gw.memory.MemoryGateway(sthis, storageMap);
+  bs.registerStoreProtocol({
+    protocol: "hack:",
+    defaultURI: () => URI.from(`hack://localhost?version=hack`),
+    serdegateway: async () => {
+      return new rt.AddKeyToDbMetaGateway(memGw, "v2");
+    },
+  });
+
+  let db: Database;
+  let ctx: { loader: bs.Loadable };
+  beforeAll(async () => {
+    db = fireproof("test", {
+      storeUrls: {
+        base: "hack://localhost",
+      },
+      keyBag: {
+        url: "memory://./dist/kb-dir-partykit?extractKey=_deprecated_internal_api",
+      },
+    });
+    await db.ready();
+    ctx = { loader: db.ledger.crdt.blockstore.loader };
+  });
+
+  it("inject key into meta", async () => {
+    const loader = db.ledger.crdt.blockstore.loader;
+    const metaStore = loader.attachedStores.local().active.meta;
+    const subscribeFn = vitest.fn();
+    const unreg = await metaStore.realGateway.subscribe(
+      ctx,
+      metaStore.url().build().setParam(PARAM.SELF_REFLECT, "x").URI(),
+      subscribeFn,
+    );
+    expect(unreg.isOk()).toBeTruthy();
+    await db.put({ val: "test" });
+
+    const dataStore = loader.attachedStores.local().active.car;
+    const kb = new rt.KeyBag(db.ledger.opts.keyBag);
+    const rDataStoreKeyItem = await kb.getNamedKey(dataStore.url().getParam(PARAM.STORE_KEY) ?? "");
+
+    await rDataStoreKeyItem.Ok().upsert("zBUFMmu5c3VdCa4r2DZTzhR", false);
+    await rDataStoreKeyItem.Ok().upsert("zH1fyizirAiYVxoaQ2XZ3Xj", false);
+
+    expect(rDataStoreKeyItem.isOk()).toBeTruthy();
+    const rUrl = await memGw.buildUrl(metaStore.url(), "main");
+    // console.log(">>>>", rUrl.Ok().toString())
+    const rGet = await memGw.get(rUrl.Ok());
+    const metas = JSON.parse(ctx.loader.sthis.txt.decode(rGet.Ok())) as rt.V2SerializedMetaKey;
+    const keyMaterials = metas.keys;
+    const dataStoreKeyMaterial = await rDataStoreKeyItem.Ok().asKeysItem();
+    expect(keyMaterials.length).toBeGreaterThan(0);
+    expect(dataStoreKeyMaterial).toEqual({
+      keys: {
+        ...(await rDataStoreKeyItem
+          .Ok()
+          .get()
+          .then(async (r) => ({
+            [r?.fingerPrint as string]: {
+              default: true,
+              fingerPrint: r?.fingerPrint,
+              key: await r?.extract().then((i) => i.keyStr),
+            },
+          }))),
+        z3boMcLEQxjZAMrVo2j3k9bZJzmSqXkQmh6q7bLZ2nRuo: {
+          default: false,
+          fingerPrint: "z3boMcLEQxjZAMrVo2j3k9bZJzmSqXkQmh6q7bLZ2nRuo",
+          key: "zH1fyizirAiYVxoaQ2XZ3Xj",
+        },
+        zG5F2VWVAs3uAFyLE5rty5WWo7zJ1oBmYTdnraxfhaHG5: {
+          default: false,
+          fingerPrint: "zG5F2VWVAs3uAFyLE5rty5WWo7zJ1oBmYTdnraxfhaHG5",
+          key: "zBUFMmu5c3VdCa4r2DZTzhR",
+        },
+      },
+      name: "@test-data@",
+    });
+
+    // expect(keyMaterials.every((k) => k === dataStoreKeyMaterial.keyStr)).toBeTruthy()
+    // expect(subscribeFn.mock.calls).toEqual([]);
+    expect(subscribeFn).toHaveBeenCalledTimes(2);
+    const addKeyToDbMetaGateway = metaStore.realGateway as rt.AddKeyToDbMetaGateway;
+    expect(
+      subscribeFn.mock.calls.map((i) => i.map((i) => i.payload.map((i: bs.DbMetaEvent) => i.eventCid.toString()))).flat(),
+    ).toEqual(addKeyToDbMetaGateway.lastDecodedMetas.map((i) => i.metas.map((i) => i.cid)));
+    unreg.Ok()();
+  });
+});
+++ b/tsconfig.json
+  "include": ["src/**/*", "cloud-backend/**/*", "tests/**/*"],
+++ b/vitest.cloud.config.ts
+import { defineConfig } from "vitest/config";
+
+import tsconfigPaths from "vite-tsconfig-paths";
+
+export default defineConfig({
+  plugins: [tsconfigPaths()],
+  test: {
+    name: "cloud",
+    exclude: [
+      "tests/react/**",
+      "**/smoke/**",
+      "**/scripts/**",
+      "**/examples/**",
+      "tests/gateway/indexeddb",
+      "tests/gateway/file",
+      "tests/blockstore/keyed-crypto-indexeddb-file.test.ts",
+    ],
+    include: ["tests/**/*test.?(c|m)[jt]s?(x)", "cloud-backend/**/*test.?(c|m)[jt]s?(x)"],
+    coverage: {
+      exclude: ["**/smoke/**", "**/scripts/**", "**/examples/**"],
+    },
+    globals: true,
+    globalSetup: "./globalSetup.cloud.ts",
+    setupFiles: "./setup.cloud.js",
+  },
+});
+++ b/vitest.workspace.ts
+import cloud from "./vitest.cloud.config.ts";
+export default defineWorkspace([
+  // force multilines
+  memory,
+  file,
+  indexeddb,
+  cloud,
+]);
