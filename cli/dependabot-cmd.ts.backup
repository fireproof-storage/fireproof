/* eslint-disable no-console */
import { command, flag, option, string } from "cmd-ts";
import { $ } from "zx";
import { SuperThis } from "@fireproof/core-types-base";

type PRStatus = "SUCCESS" | "FAILURE" | "PENDING" | "ERROR" | "REBASE-PENDING" | "NO_CHECKS" | "UNKNOWN";

interface StatusCheck {
  readonly __typename?: string;
  readonly state?: string; // For StatusContext
  readonly conclusion?: string; // For CheckRun
  readonly status?: string; // For CheckRun (COMPLETED, IN_PROGRESS, etc.)
}

interface PR {
  readonly number: number;
  readonly title: string;
  readonly author: string;
  readonly url: string;
  readonly headRefName: string;
  readonly statusCheckRollup?: StatusCheck[];
  readonly body?: string;
  readonly mergeable?: string; // MERGEABLE, CONFLICTING, UNKNOWN
  readonly mergeStateStatus?: string; // CLEAN, DIRTY, UNSTABLE, etc.
}

function isDependabotRebasing(pr: PR): boolean {
  // Check if Dependabot is rebasing based on merge state
  // DIRTY means there's a rebase in progress (assuming no conflicts)
  const hasConflict = pr.mergeable === "CONFLICTING";
  const isRebasing = pr.mergeStateStatus === "DIRTY" && !hasConflict;
  return isRebasing;
}

function getOverallStatus(pr: PR): PRStatus {
  // Check if Dependabot is rebasing first
  if (isDependabotRebasing(pr)) {
    return "REBASE-PENDING";
  }

  // Check mergeable state - if it has conflicts, it's a failure regardless of checks
  if (pr.mergeable === "CONFLICTING") {
    return "FAILURE";
  }

  if (!pr.statusCheckRollup || pr.statusCheckRollup.length === 0) {
    return "NO_CHECKS";
  }

  // Normalize status from both CheckRun and StatusContext types
  const states = pr.statusCheckRollup.map((check) => {
    // CheckRun has conclusion (FAILURE, SUCCESS, etc.) and status (COMPLETED, IN_PROGRESS, etc.)
    if (check.__typename === "CheckRun") {
      if (check.status !== "COMPLETED") {
        return "PENDING";
      }
      return check.conclusion || "UNKNOWN";
    }
    // StatusContext has state (SUCCESS, FAILURE, PENDING, ERROR)
    return check.state || "UNKNOWN";
  });

  // Determine overall status: if any fail/error, show that; if any pending, show pending; else success
  if (states.some((s) => s === "FAILURE" || s === "ERROR")) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const failedState = states.find((s) => s === "FAILURE" || s === "ERROR")!;
    return failedState === "ERROR" ? "ERROR" : "FAILURE";
  } else if (states.some((s) => s === "PENDING" || s === "IN_PROGRESS")) {
    return "PENDING";
  } else if (states.some((s) => s === "SUCCESS")) {
    // Only return SUCCESS if checks pass AND it's mergeable
    if (pr.mergeable === "MERGEABLE" || pr.mergeStateStatus === "CLEAN") {
      return "SUCCESS";
    } else {
      // Checks passed but mergeable state is unclear
      return "PENDING";
    }
  } else {
    return "UNKNOWN";
  }
}

async function checkAutoMergeEnabled(): Promise<boolean> {
  try {
    // Use GraphQL to check if auto-merge is allowed
    const result = await $`gh api graphql -f query='
      query($owner: String!, $name: String!) {
        repository(owner: $owner, name: $name) {
          autoMergeAllowed
        }
      }
    ' -f owner="$(gh repo view --json owner --jq .owner.login)" -f name="$(gh repo view --json name --jq .name)"`;

    const data = JSON.parse(result.stdout);
    return data.data.repository.autoMergeAllowed === true;
  } catch (error) {
    console.warn("Could not check auto-merge settings:", error);
    return false;
  }
}

async function fetchDependabotPRs(): Promise<PR[]> {
  try {
    const result =
      await $`gh pr list --author app/dependabot --json number,title,author,url,headRefName,statusCheckRollup,body,mergeable,mergeStateStatus --limit 100`;
    const prs = JSON.parse(result.stdout) as PR[];
    return prs;
  } catch (error) {
    console.error("Failed to fetch Dependabot PRs:", error);
    throw error;
  }
}

async function waitForPRsToSucceed(prNumbers: number[], timeoutMinutes = 30): Promise<void> {
  const startTime = Date.now();
  const timeoutMs = timeoutMinutes * 60 * 1000;
  const pollIntervalMs = 10000; // Poll every 10 seconds

  const remainingPRs = new Set(prNumbers);

  console.log(`\n‚è≥ Waiting for ${prNumbers.length} PR(s) to reach SUCCESS state (timeout: ${timeoutMinutes}m)...`);
  console.log(`   Monitoring PRs: ${Array.from(remainingPRs).join(", ")}\n`);

  while (remainingPRs.size > 0 && Date.now() - startTime < timeoutMs) {
    const prs = await fetchDependabotPRs();
    const elapsed = Math.floor((Date.now() - startTime) / 1000);

    for (const prNum of Array.from(remainingPRs)) {
      const pr = prs.find((p) => p.number === prNum);
      if (!pr) {
        console.log(`‚ö†Ô∏è  PR #${prNum} not found in list (may have been merged)`);
        remainingPRs.delete(prNum);
        continue;
      }

      const status = getOverallStatus(pr);

      if (status === "SUCCESS") {
        console.log(`‚úì PR #${prNum} reached SUCCESS state`);
        remainingPRs.delete(prNum);
      } else if (status === "FAILURE" || status === "ERROR") {
        console.log(`‚úó PR #${prNum} failed with status: ${status}`);
        remainingPRs.delete(prNum);
      }
    }

    if (remainingPRs.size > 0) {
      console.log(`‚è≥ Still waiting for ${remainingPRs.size} PR(s): ${Array.from(remainingPRs).join(", ")} (${elapsed}s elapsed)`);
      await new Promise((resolve) => setTimeout(resolve, pollIntervalMs));
    }
  }

  if (remainingPRs.size > 0) {
    console.log(`\n‚ö†Ô∏è  Timeout: ${remainingPRs.size} PR(s) did not reach SUCCESS state: ${Array.from(remainingPRs).join(", ")}`);
  } else {
    console.log(`\n‚úì All PRs reached a final state`);
  }
}

async function applyPR(pr: PR, rebase: boolean, useAutoMerge: boolean = false): Promise<void> {
  try {
    console.log(`\nProcessing PR #${pr.number}: ${pr.title}`);

    if (rebase) {
      if (useAutoMerge) {
        // Use auto-merge (repository must have it enabled)
        await $`gh pr merge ${pr.number} --auto --rebase`;
        console.log(`‚úì Enabled auto-merge for PR #${pr.number}`);
      } else {
        // Direct merge
        await $`gh pr merge ${pr.number} --rebase`;
        console.log(`‚úì Rebased and merged PR #${pr.number}`);
      }
    } else {
      // Just checkout the PR
      await $`gh pr checkout ${pr.number}`;
      console.log(`‚úì Checked out PR #${pr.number}`);
    }
  } catch (error) {
    console.error(`‚úó Failed to process PR #${pr.number}:`, error);
    throw error;
  }
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function dependabotCmd(sthis: SuperThis) {
  const cmd = command({
    name: "dependabot",
    description: "Fetch and apply Dependabot PRs",
    version: "1.0.0",
    args: {
      rebase: flag({
        long: "rebase",
        short: "r",
        description: "Automatically rebase and merge the PRs",
      }),
      apply: flag({
        long: "apply",
        short: "a",
        description: "Apply (checkout) all Dependabot PRs",
      }),
      auto: flag({
        long: "auto",
        description: "Wait for CI checks to pass before merging (requires auto-merge enabled)",
      }),
      prNumber: option({
        long: "pr",
        short: "p",
        type: string,
        defaultValue: () => "",
        description: "Apply a specific PR number",
      }),
      list: flag({
        long: "list",
        short: "l",
        description: "List all Dependabot PRs (default action)",
      }),
      wait: flag({
        long: "wait",
        short: "w",
        description: "Wait for PRs to reach SUCCESS state after applying (use with --rebase)",
      }),
    },
    handler: async (args) => {
      console.log("Fetching Dependabot PRs...");
      const prs = await fetchDependabotPRs();

      if (prs.length === 0) {
        console.log("No Dependabot PRs found.");
        return;
      }

      // Check auto-merge availability if --auto flag is used
      let autoMergeAvailable = false;
      if (args.auto && args.rebase) {
        console.log("Checking auto-merge availability...");
        autoMergeAvailable = await checkAutoMergeEnabled();

        if (!autoMergeAvailable) {
          console.error("\nERROR: Auto-merge is NOT enabled for this repository!");
          console.error("   Cannot proceed with --auto flag.");
          console.error("");
          console.error("   SOLUTION: Use --rebase without --auto for direct merging:");
          console.error(`   sh ../fireproof/cli/run.sh dependabot --rebase${args.wait ? " --wait" : ""}`);
          console.error("");
          console.error("   OR ask repository owner to enable auto-merge:");
          console.error("   Repository Settings ‚Üí General ‚Üí Pull Requests ‚Üí 'Allow auto-merge'");
          console.error("");
          process.exit(1);
        } else {
          console.log("Auto-merge is available for this repository");
        }
      }

      // List mode (default)
      if (args.list || (!args.apply && !args.rebase && !args.prNumber)) {
        console.log(`\nFound ${prs.length} Dependabot PR(s):\n`);
        prs.forEach((pr) => {
          console.log(`#${pr.number}: ${pr.title}`);
          console.log(`  URL: ${pr.url}`);
          console.log(`  Branch: ${pr.headRefName}`);

          // Display GitHub Actions status
          const overallStatus = getOverallStatus(pr);
          if (overallStatus === "NO_CHECKS") {
            console.log(`  Status: - No checks`);
          } else {
            const statusEmoji =
              overallStatus === "SUCCESS"
                ? "‚úì"
                : overallStatus === "FAILURE"
                  ? "‚úó"
                  : overallStatus === "PENDING"
                    ? "‚óã"
                    : overallStatus === "REBASE-PENDING"
                      ? "‚ö†Ô∏è "
                      : overallStatus === "ERROR"
                        ? "‚ö†"
                        : "?";
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            console.log(
              `  Status: ${statusEmoji} ${overallStatus} (${pr.statusCheckRollup!.length} check${pr.statusCheckRollup!.length !== 1 ? "s" : ""})`,
            );
          }
          console.log();
        });
        return;
      }

      // Apply specific PR
      if (args.prNumber) {
        const prNum = parseInt(args.prNumber, 10);
        const pr = prs.find((p) => p.number === prNum);
        if (!pr) {
          console.error(`PR #${prNum} not found or is not a Dependabot PR.`);
          process.exit(1);
        }
        await applyPR(pr, args.rebase, args.auto && autoMergeAvailable);
        return;
      }

      // Apply all PRs
      if (args.apply || args.rebase) {
        if (args.rebase && args.wait) {
          // With --wait, continuously process PRs until none are left
          let iteration = 0;
          let remainingPRs = prs;
          const failedToApply = new Set<number>(); // Track PRs that failed to apply

          while (remainingPRs.length > 0) {
            iteration++;
            console.log(`\n${"=".repeat(60)}`);
            console.log(`Iteration ${iteration}: Found ${remainingPRs.length} Dependabot PR(s)`);
            console.log("=".repeat(60));

            // Categorize PRs
            const successPRs = remainingPRs.filter((pr) => getOverallStatus(pr) === "SUCCESS");
            const pendingPRs = remainingPRs.filter((pr) => {
              const status = getOverallStatus(pr);
              return status === "PENDING" || status === "REBASE-PENDING";
            });
            const failedPRs = remainingPRs.filter((pr) => {
              const status = getOverallStatus(pr);
              return status === "FAILURE" || status === "ERROR";
            });

            console.log(
              `  ${successPRs.length} SUCCESS, ${pendingPRs.length} PENDING/REBASE-PENDING, ${failedPRs.length} FAILED\n`,
            );

            // Report failed PRs (check status failures)
            if (failedPRs.length > 0) {
              console.log(`Skipping ${failedPRs.length} PR(s) with failed checks:`);
              failedPRs.forEach((pr) => console.log(`  - #${pr.number}: ${pr.title} (${getOverallStatus(pr)})`));
              console.log();
            }

            // Report PRs that failed to apply in previous iterations
            if (failedToApply.size > 0) {
              const stillFailed = successPRs.filter((pr) => failedToApply.has(pr.number));
              if (stillFailed.length > 0) {
                console.log(`Retrying ${stillFailed.length} PR(s) that failed to apply previously:`);
                stillFailed.forEach((pr) => console.log(`  - #${pr.number}: ${pr.title}`));
                console.log();
              }
            }

            // Process SUCCESS PRs first
            if (successPRs.length > 0) {
              console.log(`Rebasing ${successPRs.length} PR(s) with SUCCESS status:\n`);
              for (const pr of successPRs) {
                try {
                  await applyPR(pr, true, args.auto && autoMergeAvailable);
                  // If successful, remove from failed list
                  failedToApply.delete(pr.number);
                } catch (error) {
                  console.error(`‚úó Failed to apply PR #${pr.number}, will retry in next iteration.`);
                  failedToApply.add(pr.number);
                }
              }
            }

            // Wait for pending PRs if any
            if (pendingPRs.length > 0) {
              const pendingNumbers = pendingPRs.map((pr) => pr.number);
              await waitForPRsToSucceed(pendingNumbers);
            }

            // If we only processed pending PRs (no SUCCESS PRs to rebase), skip the inter-iteration wait
            // Otherwise wait before checking for new PRs
            if (successPRs.length === 0 && pendingPRs.length > 0) {
              // Just waited for PRs, immediately check their status for next iteration
              console.log("\nüîÑ Checking status of completed PRs...");
            } else {
              // Wait before next iteration to avoid hammering the API
              console.log("\n‚è≥ Waiting 10 seconds before next iteration...");
              await new Promise((resolve) => setTimeout(resolve, 10000));
            }

            // Refresh the PR list
            remainingPRs = await fetchDependabotPRs();

            // If no PRs left, we're done
            if (remainingPRs.length === 0) {
              if (failedToApply.size > 0) {
                console.log(
                  `\n‚ö†Ô∏è  Completed, but ${failedToApply.size} PR(s) could not be applied: ${Array.from(failedToApply).join(", ")}`,
                );
              } else {
                console.log("\n‚úì All Dependabot PRs have been processed!");
              }
              break;
            }

            // Check if we're stuck (only failed-to-apply PRs remain)
            const onlyFailedRemain = remainingPRs.every((pr) => failedToApply.has(pr.number));
            if (onlyFailedRemain && successPRs.length === 0 && pendingPRs.length === 0) {
              console.log(`\n‚ö†Ô∏è  Cannot proceed: Only PRs that failed to apply remain in the list.`);
              console.log(`Failed PRs: ${Array.from(failedToApply).join(", ")}`);
              break;
            }
          }
        } else {
          // Original logic for --rebase without --wait or for --apply
          let prsToProcess = prs;

          if (args.rebase) {
            // Without --wait, only process SUCCESS PRs
            prsToProcess = prs.filter((pr) => getOverallStatus(pr) === "SUCCESS");

            const rebasingCount = prs.filter((pr) => getOverallStatus(pr) === "REBASE-PENDING").length;
            const pendingCount = prs.filter((pr) => getOverallStatus(pr) === "PENDING").length;
            const failedCount = prs.filter((pr) => {
              const status = getOverallStatus(pr);
              return status === "FAILURE" || status === "ERROR";
            }).length;

            console.log(`\nFound ${prs.length} Dependabot PR(s), ${prsToProcess.length} ready to rebase.\n`);
            if (rebasingCount > 0) {
              console.log(`${rebasingCount} PR(s) with REBASE-PENDING status.`);
            }
            if (pendingCount > 0) {
              console.log(`${pendingCount} PR(s) with PENDING status.`);
            }
            if (failedCount > 0) {
              console.log(`Skipping ${failedCount} PR(s) with FAILURE/ERROR status.`);
            }
            console.log();
          } else {
            console.log(`\nProcessing ${prs.length} Dependabot PR(s)...\n`);
          }

          for (const pr of prsToProcess) {
            try {
              await applyPR(pr, args.rebase, args.auto && autoMergeAvailable);
            } catch (error) {
              console.error(`Skipping PR #${pr.number} due to error.`);
            }
          }
        }

        console.log("\nDone processing Dependabot PRs.");
      }
    },
  });
  return cmd;
}
