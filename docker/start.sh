#!/bin/bash
# Fireproof Cloud - Docker Startup Script
#
# Usage:
#   ./docker/start.sh          # Start services (pulls pre-built images if available)
#   ./docker/start.sh --setup  # Generate keys, pull images, write .env, start
#   ./docker/start.sh --build  # Build from source and start
#   ./docker/start.sh --all    # Start all services including todo-app
#   ./docker/start.sh --verify # Verify all proxy routes are working
#   ./docker/start.sh --infra  # Start infrastructure only
#   ./docker/start.sh --down   # Stop all services
#   ./docker/start.sh --clean  # Stop and remove volumes

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

cd "$PROJECT_ROOT"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

CLOUD_BACKEND_IMAGE="ghcr.io/fireproof-storage/fireproof/cloud-backend:latest"

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Ensure .env exists
ensure_env() {
    if [ ! -f ".env" ]; then
        if [ -f ".env.docker" ]; then
            log_info "Creating .env from .env.docker..."
            cp .env.docker .env
        else
            log_error ".env.docker not found. Cannot create .env file."
            exit 1
        fi
    fi
}

# Generate keys and write .env using the pre-pulled cloud-backend image
generate_env() {
    log_info "Generating session tokens and device ID CA certificate..."

    # Pull pre-built images first
    log_info "Pulling pre-built images from GHCR..."
    docker compose pull || log_warn "Some images could not be pulled. Local build will be used as fallback."

    log_info "Running key generation using cloud-backend image..."
    local output
    output=$(docker run --rm "$CLOUD_BACKEND_IMAGE" bash -c '
        echo "===KEYS==="
        pnpm exec tsx cli/main.ts key --generatePair 2>/dev/null
        echo "===CA==="
        pnpm exec tsx cli/main.ts deviceId ca-cert --common-name "Docker Dev CA" --envVars 2>/dev/null
    ')

    # Parse generated values from container output
    local cloud_public cloud_secret ca_priv_key ca_cert
    cloud_public=$(echo "$output" | grep '^CLOUD_SESSION_TOKEN_PUBLIC=' | cut -d'=' -f2-)
    cloud_secret=$(echo "$output" | grep '^CLOUD_SESSION_TOKEN_SECRET=' | cut -d'=' -f2-)
    ca_priv_key=$(echo "$output" | grep '^DEVICE_ID_CA_PRIV_KEY=' | cut -d'=' -f2-)
    ca_cert=$(echo "$output" | grep '^DEVICE_ID_CA_CERT=' | cut -d'=' -f2-)

    if [ -z "$cloud_public" ] || [ -z "$cloud_secret" ]; then
        log_error "Failed to generate session tokens."
        echo "Container output:"
        echo "$output"
        exit 1
    fi

    if [ -z "$ca_priv_key" ] || [ -z "$ca_cert" ]; then
        log_error "Failed to generate device ID CA certificate."
        echo "Container output:"
        echo "$output"
        exit 1
    fi

    log_info "Keys generated successfully."

    # Read Clerk keys from env vars, fall back to .env.docker defaults
    local clerk_secret clerk_pub clerk_vite_pub clerk_jwt_url
    if [ -f ".env.docker" ]; then
        clerk_secret="${CLERK_SECRET_KEY:-$(grep '^CLERK_SECRET_KEY=' .env.docker | cut -d'=' -f2-)}"
        clerk_pub="${CLERK_PUBLISHABLE_KEY:-$(grep '^CLERK_PUBLISHABLE_KEY=' .env.docker | cut -d'=' -f2-)}"
        clerk_vite_pub="${VITE_CLERK_PUBLISHABLE_KEY:-$(grep '^VITE_CLERK_PUBLISHABLE_KEY=' .env.docker | cut -d'=' -f2-)}"
        clerk_jwt_url="${CLERK_PUB_JWT_URL:-$(grep '^CLERK_PUB_JWT_URL=' .env.docker | cut -d'=' -f2-)}"
    else
        clerk_secret="${CLERK_SECRET_KEY:-}"
        clerk_pub="${CLERK_PUBLISHABLE_KEY:-}"
        clerk_vite_pub="${VITE_CLERK_PUBLISHABLE_KEY:-}"
        clerk_jwt_url="${CLERK_PUB_JWT_URL:-}"
    fi

    log_info "Writing .env file..."

    cat > .env <<ENVEOF
# Fireproof Cloud - Docker Development Environment Variables
# Auto-generated by ./docker/start.sh --setup

# Session Tokens (generated)
CLOUD_SESSION_TOKEN_PUBLIC=${cloud_public}
CLOUD_SESSION_TOKEN_SECRET=${cloud_secret}

# Clerk Authentication
CLERK_SECRET_KEY=${clerk_secret}
CLERK_PUBLISHABLE_KEY=${clerk_pub}
VITE_CLERK_PUBLISHABLE_KEY=${clerk_vite_pub}
CLERK_PUB_JWT_URL=${clerk_jwt_url}

# Device ID CA (generated)
DEVICE_ID_CA_PRIV_KEY=${ca_priv_key}
DEVICE_ID_CA_CERT=${ca_cert}

# Service Configuration
ENDPOINT_PORT=8909
FP_ENDPOINT=http://cloud-backend:8909
DASHBOARD_PORT=7370
NODE_ENV=development
ENVIRONMENT=dev
VERSION=FP-MSG-1.0
FP_DEBUG=true
MAX_IDLE_TIME=300

# Limits
MAX_LEDGERS=50
MAX_TENANTS=100
MAX_ADMIN_USERS=10
MAX_MEMBER_USERS=50
MAX_INVITES=100
MAX_APPID_BINDINGS=50

# Blob Proxy URL
# For local development, the default (http://localhost:8080) works fine.
# For remote/VM deployments, set this to the public URL of the proxy
# so that blob download URLs are reachable by external clients.
BLOB_PROXY_URL=${BLOB_PROXY_URL:-http://localhost:8080}
ENVEOF

    log_info ".env written with freshly generated keys."
}

# Start infrastructure only
start_infra() {
    log_info "Starting infrastructure services..."
    docker compose -f docker-compose.infra.yaml up -d

    log_info "Waiting for infrastructure to be ready..."
    sleep 5

    echo ""
    log_info "Infrastructure is ready!"
    echo ""
}

# Wait for services to be ready and print status
wait_and_print_status() {
    log_info "Waiting for services to be ready..."

    # Wait for services
    echo -n "Waiting for cloud-backend"
    for i in {1..30}; do
        if curl -s http://localhost:8909/ > /dev/null 2>&1; then
            echo " ready!"
            break
        fi
        echo -n "."
        sleep 2
    done

    echo -n "Waiting for dashboard"
    for i in {1..30}; do
        if curl -s http://localhost:7370/ > /dev/null 2>&1; then
            echo " ready!"
            break
        fi
        echo -n "."
        sleep 2
    done

    echo -n "Waiting for proxy"
    for i in {1..30}; do
        if curl -s http://localhost:8080/proxy/health > /dev/null 2>&1; then
            echo " ready!"
            break
        fi
        echo -n "."
        sleep 2
    done

    echo ""
    log_info "Fireproof Cloud is ready!"
    echo ""
    echo "Proxy (primary entry point):"
    echo "  http://localhost:8080"
    echo ""
    echo "Direct access (debug):"
    echo "  Cloud Backend:  http://localhost:8909"
    echo "  Dashboard:      http://localhost:7370"
    echo ""
    echo "Logs:"
    echo "  docker compose logs -f"
    echo ""
}

# Start all services (uses pre-built images if available, builds if not)
start_all() {
    ensure_env

    log_info "Starting Fireproof Cloud services..."
    docker compose up -d

    wait_and_print_status
}

# Start all services including todo-app (frontend profile)
start_all_with_frontend() {
    ensure_env

    log_info "Starting all Fireproof Cloud services (including todo-app)..."
    docker compose --profile frontend up -d

    wait_and_print_status
}

# Build from source and start
build_and_start() {
    ensure_env

    log_info "Building and starting all Fireproof Cloud services from source..."
    log_warn "This may take several minutes on first run..."

    docker compose up --build -d

    wait_and_print_status
}

# Full automated setup: pull images, generate keys, write .env, start
setup() {
    log_info "Starting full automated setup..."
    generate_env
    start_all
    log_info "Setup complete."
}

# Verify all proxy routes
verify() {
    local base="http://localhost:8080"
    local pass=0
    local fail=0

    echo "Verifying proxy routes at ${base} ..."
    echo ""

    check_route() {
        local path="$1"
        local label="$2"
        local status
        status=$(curl -s -o /dev/null -w '%{http_code}' "${base}${path}" 2>/dev/null || echo "000")
        if [ "$status" -ge 200 ] && [ "$status" -lt 400 ]; then
            printf "  %-20s ${GREEN}OK${NC} (HTTP %s)\n" "$label" "$status"
            pass=$((pass + 1))
        else
            printf "  %-20s ${RED}FAIL${NC} (HTTP %s)\n" "$label" "$status"
            fail=$((fail + 1))
        fi
    }

    check_ws() {
        local path="$1"
        local label="$2"
        local headers
        headers=$(curl -s -I -H "Upgrade: websocket" -H "Connection: Upgrade" "${base}${path}" 2>/dev/null || echo "")
        if echo "$headers" | grep -qi "upgrade"; then
            printf "  %-20s ${GREEN}OK${NC} (upgrade header)\n" "$label"
            pass=$((pass + 1))
        else
            # WebSocket endpoint may return 426 or similar -- still counts as reachable
            local status
            status=$(curl -s -o /dev/null -w '%{http_code}' "${base}${path}" 2>/dev/null || echo "000")
            if [ "$status" != "000" ]; then
                printf "  %-20s ${GREEN}OK${NC} (reachable, HTTP %s)\n" "$label" "$status"
                pass=$((pass + 1))
            else
                printf "  %-20s ${RED}FAIL${NC} (unreachable)\n" "$label"
                fail=$((fail + 1))
            fi
        fi
    }

    check_route "/" "/"
    check_route "/proxy/health" "/proxy/health"
    check_route "/api/" "/api/"
    check_route "/fp/cloud/" "/fp/cloud/"
    check_route "/.well-known/" "/.well-known/"
    check_ws "/ws" "/ws"

    echo ""
    echo "Results: ${pass} passed, ${fail} failed"
    if [ "$fail" -gt 0 ]; then
        exit 1
    fi
}

# Stop services
stop_services() {
    log_info "Stopping services..."
    docker compose -f docker-compose.infra.yaml down 2>/dev/null || true
    docker compose --profile frontend down 2>/dev/null || true
    docker compose down 2>/dev/null || true
    log_info "Services stopped."
}

# Clean up
clean_up() {
    log_info "Stopping services and removing volumes..."
    docker compose -f docker-compose.infra.yaml down -v 2>/dev/null || true
    docker compose --profile frontend down -v 2>/dev/null || true
    docker compose down -v 2>/dev/null || true
    log_info "Cleanup complete."
}

# Main
case "${1:-}" in
    --setup|-s)
        setup
        ;;
    --build|-b)
        build_and_start
        ;;
    --all|-a)
        start_all_with_frontend
        ;;
    --verify|-v)
        verify
        ;;
    --infra|-i)
        start_infra
        ;;
    --down|-d)
        stop_services
        ;;
    --clean|-c)
        clean_up
        ;;
    --help|-h)
        echo "Fireproof Cloud Docker Startup Script"
        echo ""
        echo "Usage:"
        echo "  ./docker/start.sh          Start services (uses pre-built images if available)"
        echo "  ./docker/start.sh --setup  Pull images, generate keys, write .env, start"
        echo "  ./docker/start.sh --build  Build from source and start"
        echo "  ./docker/start.sh --all    Start all services including todo-app"
        echo "  ./docker/start.sh --verify Verify all proxy routes are working"
        echo "  ./docker/start.sh --infra  Start infrastructure services"
        echo "  ./docker/start.sh --down   Stop all services"
        echo "  ./docker/start.sh --clean  Stop and remove volumes"
        echo "  ./docker/start.sh --help   Show this help"
        echo ""
        echo "Fresh VM setup:"
        echo "  git clone https://github.com/fireproof-storage/fireproof.git"
        echo "  cd fireproof"
        echo "  ./docker/start.sh --setup"
        echo ""
        echo "Environment variables (override Clerk defaults from .env.docker):"
        echo "  CLERK_SECRET_KEY           Clerk secret key"
        echo "  CLERK_PUBLISHABLE_KEY      Clerk publishable key"
        echo "  VITE_CLERK_PUBLISHABLE_KEY Clerk publishable key (Vite)"
        echo "  CLERK_PUB_JWT_URL          Clerk JWT public key URL"
        ;;
    *)
        start_all
        ;;
esac
